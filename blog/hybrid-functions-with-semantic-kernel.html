<!DOCTYPE html><html lang="zh-Hant"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/f71b761575b48bd6.css" data-precedence="next"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/e57a9f01512809bb.css" data-precedence="next"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/4bb1c53d4d41ca49.css" data-precedence="next"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/45df6ee84bc085cd.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="https://qwer820921.github.io/_next/static/chunks/webpack-40d0a3f2167e9bf7.js"/><script src="https://qwer820921.github.io/_next/static/chunks/4bd1b696-e100a0b1879d5e6b.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/1684-9b53760636e10952.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/main-app-c0d2570cf703bee2.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/6283-1586b7e20e5a28d4.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/app/layout-984d35e9d146542e.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/app/blog/%5Bslug%5D/page-625d55d419426b5e.js" async=""></script><link rel="preload" href="https://qwer820921.github.io/_next/static/chunks/2990.570e3922e6932b47.js" as="script" fetchPriority="low"/><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-CCKVESHCQ1" as="script"/><link rel="preload" href="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2709303513603814" as="script" crossorigin=""/><link rel="icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/logo192.png"/><link rel="manifest" href="/manifest.json"/><link rel="preload" href="/logo192.png" as="image"/><title>【架構設計】Semantic Kernel 實戰：混合使用 Native Function 與 Semantic Function | 子yee 萬事屋 | 子yee</title><meta name="description" content="深入探討 Microsoft Semantic Kernel 框架，教學如何在 .NET 9 環境下，將 C# 原生程式碼 (Native Function) 與 LLM 語意邏輯 (Semantic Function) 巧妙結合，實現強大的 AI 應用。"/><meta name="author" content="子yee"/><meta name="keywords" content="子yee 萬事屋, 台股查詢, 自選股, 技術小工具, 股票資訊平台, 技術顧問, 自動化工具"/><meta name="google-site-verification" content="adHIcDQiasHY4YzPlrpmSSPKl7Oj1WxrPJ_4GV4PQcM"/><meta property="og:title" content="【架構設計】Semantic Kernel 實戰：混合使用 Native Function 與 Semantic Function"/><meta property="og:description" content="深入探討 Microsoft Semantic Kernel 框架，教學如何在 .NET 9 環境下，將 C# 原生程式碼 (Native Function) 與 LLM 語意邏輯 (Semantic Function) 巧妙結合，實現強大的 AI 應用。"/><meta property="og:image" content="https://qwer820921.github.io/images/img15.jpg"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:alt" content="【架構設計】Semantic Kernel 實戰：混合使用 Native Function 與 Semantic Function"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="【架構設計】Semantic Kernel 實戰：混合使用 Native Function 與 Semantic Function"/><meta name="twitter:description" content="深入探討 Microsoft Semantic Kernel 框架，教學如何在 .NET 9 環境下，將 C# 原生程式碼 (Native Function) 與 LLM 語意邏輯 (Semantic Function) 巧妙結合，實現強大的 AI 應用。"/><meta name="twitter:image" content="https://qwer820921.github.io/images/img15.jpg"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="https://qwer820921.github.io/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><main class="container-fluid p-0"><article class="container py-5"><div class="row justify-content-center"><div class="col-12 col-lg-8"><div class="card blogPost_articleCard__LIiRr"><div class="card-body blogPost_cardBody__5xHPD"><header class="blogPost_articleHeader__dQ5vG"><div id="static-back-btn" style="display:inline-flex;margin-bottom:1rem;cursor:pointer;position:relative;z-index:1"><div class="btn d-inline-flex align-items-center gap-2 shadow rounded-pill px-4 py-2 text-decoration-none" role="button" style="pointer-events:auto;background-color:#fff;backdrop-filter:none;border:1px solid rgba(0,0,0,0.08);color:#495057;font-weight:500;transition:all 0.2s ease;cursor:pointer"><span>回到文章列表</span></div></div><h1 class="blogPost_articleTitle__BCXQE">【架構設計】Semantic Kernel 實戰：混合使用 Native Function 與 Semantic Function</h1><div class="blogPost_articleMeta__1R_wB"><div class="blogPost_metaItem__xpKuj"><i class="bi bi-person-fill blogPost_metaIcon__h8wBb"></i><span class="blogPost_metaLabel__y0uVD">作者:</span>子yee</div><div class="blogPost_metaItem__xpKuj"><i class="bi bi-calendar3 blogPost_metaIcon__h8wBb"></i><span class="blogPost_metaLabel__y0uVD">日期:</span>2026-02-06</div></div></header><div class="blogContent_blogContent__VY_R4"><h2>1. Overview</h2>
<p>隨著生成式 AI 技術的快速發展，將大型語言模型（LLM）的能力整合到傳統應用程式中，已成為現代軟體開發的趨勢。然而，LLM 擅長處理非結構化數據、理解語意和生成創意內容，卻不擅長執行精確的邏輯運算、存取外部系統或處理大量結構化數據。為了解決這個問題，Microsoft 推出了 <strong>Semantic Kernel (SK)</strong> 框架，它提供了一個輕量級的 SDK，旨在將 LLM 與傳統程式語言（如 C#, Python, Java）無縫結合，讓開發者能夠構建出既具備 AI 智慧又擁有確定性邏輯的應用程式 [1]。</p>
<p>Semantic Kernel 的核心概念之一是將應用程式的能力抽象為 <strong>Skills</strong>，而每個 Skill 又由一個或多個 <strong>Functions</strong> 組成。這些 Functions 主要分為兩大類：</p>
<ol>
<li><strong>Native Function (原生技能)</strong>：由傳統程式語言（例如 C#）編寫，負責執行確定性的、邏輯嚴謹的任務，如查詢資料庫、呼叫外部 API、執行複雜計算等。</li>
<li><strong>Semantic Function (語意技能)</strong>：由提示詞（Prompt）定義，利用 LLM 的能力來處理語意理解、內容生成、摘要或格式轉換等任務。</li>
</ol>
<p>本文件將深入探討 Semantic Kernel 在 .NET 9 環境下的核心架構，並透過實戰範例，演示如何巧妙地將 Native Function 與 Semantic Function 串聯（Chain）起來，讓 AI 能夠先透過 Native Function 從資料庫中獲取精確的結構化數據，再利用 Semantic Function 將這些數據轉化為易讀、富有洞察力的報告。這種混合使用模式，將極大提升 AI 應用程式的實用性、精確性和自動化程度。</p>
<h2>2. Architecture / Design</h2>
<p>Semantic Kernel 的設計哲學是將 LLM 視為一個強大的推理引擎，而 Native Functions 則為這個引擎提供了與真實世界互動的「手腳」。透過將這些能力組織成 Plugins 和 Functions，並由 Kernel 進行協調，我們可以構建出高度智能且可靠的 AI 應用程式 [2]。</p>
<h3>2.1 Semantic Kernel 核心組件</h3>
<p>Semantic Kernel 的核心架構圍繞著以下幾個關鍵組件：</p>
<ul>
<li><strong>Kernel</strong>：這是 Semantic Kernel 的核心引擎，負責協調所有 Functions 的執行。它管理 Plugins、Functions、記憶體（Memory）和 LLM 服務的連接。開發者透過 <code>Kernel</code> 實例來執行 AI 任務 [3]。</li>
<li><strong>Plugins (技能集)</strong>：Plugins 是相關 Functions 的集合。一個 Plugin 可以包含多個 Native Functions 和 Semantic Functions。例如，一個 <code>DatabasePlugin</code> 可能包含 <code>GetSalesData</code> (Native) 和 <code>SummarizeData</code> (Semantic) [4]。</li>
<li><strong>Native Function (原生技能)</strong>：<!-- -->
<ul>
<li><strong>定義</strong>：使用 C# 等傳統程式語言編寫的函數。它們是確定性的，執行傳統的程式邏輯。</li>
<li><strong>職責</strong>：主要用於執行需要精確控制、外部系統互動或大量數據處理的任務，例如：<!-- -->
<ul>
<li>查詢 SQL 資料庫或 NoSQL 資料庫。</li>
<li>呼叫 RESTful API 或 gRPC 服務。</li>
<li>執行檔案讀寫操作。</li>
<li>進行複雜的數學計算或數據轉換。</li>
</ul>
</li>
<li><strong>優點</strong>：結果確定、效能高、可進行完整的單元測試和整合測試。</li>
</ul>
</li>
<li><strong>Semantic Function (語意技能)</strong>：<!-- -->
<ul>
<li><strong>定義</strong>：由一個或多個提示詞模板（Prompt Template）定義，利用 LLM 的能力來完成任務。它們是非確定性的，結果會因 LLM 的生成能力而異。</li>
<li><strong>職責</strong>：主要用於處理需要語意理解、內容生成或格式轉換的任務，例如：<!-- -->
<ul>
<li>總結長篇文本。</li>
<li>根據數據生成自然語言報告。</li>
<li>將 JSON 數據轉換為易讀的 Markdown 格式。</li>
<li>進行情感分析或意圖識別。</li>
</ul>
</li>
<li><strong>優點</strong>：處理模糊需求能力強、開發速度快、可快速迭代。</li>
</ul>
</li>
<li><strong>KernelArguments</strong>：這是一個用於在 Functions 之間傳遞狀態和參數的物件。它類似於一個字典，可以儲存多個鍵值對，供不同的 Functions 讀取和寫入 [5]。</li>
</ul>
<h3>2.2 混合工作流設計：Native + Semantic Function 串聯</h3>
<p>本文件的核心目標是演示如何將 Native Function 與 Semantic Function 串聯起來，構建一個從資料庫查詢到報告生成的自動化工作流。以下是一個典型的串聯邏輯：</p>
<ol>
<li><strong>使用者輸入 (User Input)</strong>：使用者向 AI 應用程式提出一個高層次的需求，例如：「請生成上週的銷售數據週報。」</li>
<li><strong>AI 意圖識別與規劃 (AI Intent Recognition &amp; Planning)</strong>：如果應用程式使用了 Planner（規劃器），AI 會分析使用者意圖，並自動規劃出一個執行計畫，決定需要呼叫哪些 Functions 以及它們的順序。即使沒有 Planner，開發者也可以手動編排 Functions 的執行順序。</li>
<li><strong>Native Function 執行 (Data Retrieval)</strong>：<!-- -->
<ul>
<li>首先，Kernel 會呼叫一個 Native Function，例如 <code>SalesDataPlugin.GetWeeklySalesData(startDate, endDate)</code>。這個 Native Function 會連接到後端 SQL Server 資料庫，執行一個精確的 SQL 查詢，獲取上週的銷售數據。數據通常以結構化的 JSON 格式返回。</li>
<li>Native Function 將查詢到的 JSON 數據儲存到 <code>KernelArguments</code> 中，作為後續 Functions 的輸入。</li>
</ul>
</li>
<li><strong>Semantic Function 執行 (Report Generation)</strong>：<!-- -->
<ul>
<li>接著，Kernel 會呼叫一個 Semantic Function，例如 <code>ReportPlugin.GenerateWeeklyReport(salesDataJson)</code>。這個 Semantic Function 的提示詞模板會被設計成接收 JSON 格式的銷售數據，並指示 LLM 將其轉化為一份易讀、摘要性的週報（例如 Markdown 格式）。</li>
<li>LLM 根據提示詞和 <code>KernelArguments</code> 中提供的銷售數據，生成最終的週報內容。</li>
</ul>
</li>
<li><strong>輸出呈現 (Output Presentation)</strong>：應用程式將 LLM 生成的週報內容呈現給使用者。</li>
</ol>
<p>這種串聯模式充分利用了 Native Function 的精確性和 Semantic Function 的語意理解能力，實現了數據驅動的智能內容生成。</p>
<h2>3. Prerequisites</h2>
<p>要實作 Semantic Kernel 應用程式，特別是結合 Native Function 與 Semantic Function，您需要具備以下環境和知識：</p>
<ul>
<li><strong>.NET 9 SDK</strong>：確保您的開發環境已安裝 .NET 9 SDK 或更高版本。Semantic Kernel 與 .NET 生態系統緊密整合。</li>
<li><strong>C# 程式設計知識</strong>：熟悉 C# 語言特性、非同步程式設計（<code>async/await</code>）和物件導向程式設計。</li>
<li><strong>LLM 服務</strong>：需要一個可用的 LLM 服務，例如 Azure OpenAI Service、OpenAI API 或其他支援的 LLM 提供商。您需要相應的 API 金鑰和端點。</li>
<li><strong>Semantic Kernel NuGet 套件</strong>：安裝 <code>Microsoft.SemanticKernel</code> 及其相關套件。</li>
<li><strong>資料庫知識</strong>：如果 Native Function 需要與資料庫互動，您需要了解 SQL Server 或其他資料庫的基本操作。</li>
<li><strong>Visual Studio 或 VS Code</strong>：推薦使用這些 IDE 進行 .NET 開發。</li>
</ul>
<h2>4. Implementation / Code Example</h2>
<p>本節將提供一個使用 C# 和 .NET 9 實作 Semantic Kernel 混合 Native Function 與 Semantic Function 的範例。我們將模擬一個從資料庫獲取銷售數據，然後生成週報的場景。</p>
<h3>4.1 專案初始化</h3>
<p>首先，創建一個新的 .NET Console 專案並安裝必要的 NuGet 套件：</p>
<pre><code class="language-bash">dotnet new console -n SemanticKernelHybridDemo
cd SemanticKernelHybridDemo
dotnet add package Microsoft.SemanticKernel
dotnet add package Microsoft.SemanticKernel.Connectors.OpenAI # 根據您使用的 LLM 選擇連接器
dotnet add package Microsoft.Extensions.Configuration.Json # 用於配置管理
dotnet add package Microsoft.Extensions.Configuration.EnvironmentVariables
dotnet add package System.Data.SqlClient # 模擬 SQL Server 連接
</code></pre>
<h3>4.2 配置 LLM 服務</h3>
<p>創建 <code>appsettings.json</code> 檔案來儲存您的 LLM 服務配置：</p>
<pre><code class="language-json">{
  &quot;OpenAI&quot;: {
    &quot;ModelId&quot;: &quot;gpt-4o&quot;,
    &quot;ApiKey&quot;: &quot;YOUR_OPENAI_API_KEY&quot;
  }
}
</code></pre>
<p>或者使用環境變數來儲存 <code>OPENAI_API_KEY</code>。</p>
<h3>4.3 定義 Native Function (SalesDataPlugin.cs)</h3>
<p>這個 Native Function 模擬從 SQL Server 獲取銷售數據。在實際應用中，這裡會使用 Entity Framework Core 或 ADO.NET 進行真實的資料庫操作。</p>
<pre><code class="language-csharp">using Microsoft.SemanticKernel;
using System.ComponentModel;
using System.Text.Json;

public class SalesDataPlugin
{
    [KernelFunction, Description(&quot;從資料庫獲取指定日期範圍內的銷售數據。&quot;)]
    public async Task&lt;string&gt; GetWeeklySalesData(
        [Description(&quot;開始日期，格式為 YYYY-MM-DD&quot;)] string startDate,
        [Description(&quot;結束日期，格式為 YYYY-MM-DD&quot;)] string endDate)
    {
        // 模擬從 SQL Server 查詢數據
        // 在實際應用中，這裡會是真實的資料庫查詢邏輯
        Console.WriteLine($&quot;\n[Native Function] 正在從資料庫獲取 {startDate} 到 {endDate} 的銷售數據...&quot;);

        // 模擬數據庫查詢結果
        var salesData = new List&lt;object&gt;
        {
            new { Product = &quot;筆記型電腦&quot;, Quantity = 150, Revenue = 150000.00, Date = &quot;2026-02-03&quot; },
            new { Product = &quot;智慧型手機&quot;, Quantity = 200, Revenue = 120000.00, Date = &quot;2026-02-04&quot; },
            new { Product = &quot;平板電腦&quot;, Quantity = 80, Revenue = 40000.00, Date = &quot;2026-02-05&quot; },
            new { Product = &quot;智慧手錶&quot;, Quantity = 300, Revenue = 60000.00, Date = &quot;2026-02-06&quot; },
            new { Product = &quot;耳機&quot;, Quantity = 500, Revenue = 25000.00, Date = &quot;2026-02-07&quot; }
        };

        await Task.Delay(500); // 模擬網路延遲

        var jsonOptions = new JsonSerializerOptions { WriteIndented = true };
        string jsonResult = JsonSerializer.Serialize(salesData, jsonOptions);
        Console.WriteLine(&quot;[Native Function] 銷售數據獲取完成。&quot;);
        return jsonResult;
    }
}
</code></pre>
<h3>4.4 定義 Semantic Function (ReportPlugin)</h3>
<p>Semantic Function 通常由一個提示詞模板文件 (<code>skprompt.txt</code>) 和一個配置文件 (<code>config.json</code>) 組成。為了簡化範例，我們直接在程式碼中定義提示詞。</p>
<pre><code class="language-csharp">// ReportPlugin.cs (或直接在 Program.cs 中定義)

public static class ReportPlugin
{
    public static string GenerateWeeklyReportPrompt = @&quot;
    你是一個專業的商業分析師，請根據提供的 JSON 格式銷售數據，生成一份簡潔、易讀的週報。
    週報應包含以下部分：
    1. 總銷售額和總銷售量。
    2. 表現最佳的產品（銷售額最高）。
    3. 任何值得注意的趨勢或觀察。

    請以 Markdown 格式輸出報告。

    銷售數據 (JSON 格式):
    {{$input}}

    週報:
    &quot;;
}
</code></pre>
<h3>4.5 串聯 Native 與 Semantic Function (Program.cs)</h3>
<pre><code class="language-csharp">using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Connectors.OpenAI;
using Microsoft.Extensions.Configuration;
using System.Text.Json;

public class Program
{
    public static async Task Main(string[] args)
    {
        // 1. 配置 Kernel
        var configuration = new ConfigurationBuilder()
            .AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
            .AddEnvironmentVariables()
            .Build();

        var builder = Kernel.CreateBuilder();

        // 根據配置添加 LLM 服務
        if (configuration[&quot;OpenAI:ApiKey&quot;] is string openAIApiKey &amp;&amp; !string.IsNullOrEmpty(openAIApiKey))
        {
            builder.AddOpenAIChatCompletion(
                modelId: configuration[&quot;OpenAI:ModelId&quot;] ?? &quot;gpt-4o&quot;,
                apiKey: openAIApiKey);
        }
        else
        {
            Console.WriteLine(&quot;請在 appsettings.json 或環境變數中配置 OpenAI:ApiKey。&quot;);
            return;
        }

        Kernel kernel = builder.Build();

        // 2. 導入 Native Function Plugin
        kernel.ImportPluginFromObject(new SalesDataPlugin(), &quot;SalesDataPlugin&quot;);
        Console.WriteLine(&quot;Native Function Plugin &#x27;SalesDataPlugin&#x27; 導入成功。&quot;);

        // 3. 創建 Semantic Function
        var generateReportFunction = kernel.CreateFunctionFromPrompt(
            ReportPlugin.GenerateWeeklyReportPrompt,
            functionName: &quot;GenerateWeeklyReport&quot;,
            description: &quot;根據銷售數據生成週報&quot;
        );
        Console.WriteLine(&quot;Semantic Function &#x27;GenerateWeeklyReport&#x27; 創建成功。&quot;);

        // 4. 定義日期範圍
        string startDate = &quot;2026-02-03&quot;;
        string endDate = &quot;2026-02-07&quot;;

        // 5. 執行工作流：Native Function -&gt; Semantic Function
        Console.WriteLine(&quot;\n--- 開始生成週報工作流 ---&quot;);

        // 步驟 1: 呼叫 Native Function 獲取銷售數據
        var salesDataJson = await kernel.InvokeAsync&lt;string&gt;(
            &quot;SalesDataPlugin&quot;,
            &quot;GetWeeklySalesData&quot;,
            new KernelArguments { { &quot;startDate&quot;, startDate }, { &quot;endDate&quot;, endDate } }
        );

        Console.WriteLine(&quot;\n[Main] 獲取到的銷售數據 (JSON):\n&quot; + salesDataJson);

        // 步驟 2: 呼叫 Semantic Function 生成報告
        var report = await kernel.InvokeAsync&lt;string&gt;(
            generateReportFunction,
            new KernelArguments { { &quot;input&quot;, salesDataJson } } // 將 Native Function 的輸出作為 Semantic Function 的輸入
        );

        Console.WriteLine(&quot;\n--- 生成的週報 ---&quot;);
        Console.WriteLine(report);

        Console.WriteLine(&quot;\n--- 週報生成工作流完成 ---&quot;);
    }
}
</code></pre>
<h3>4.6 運行專案</h3>
<p>確保您的 <code>appsettings.json</code> 中的 <code>OpenAI:ApiKey</code> 已正確配置，然後運行：</p>
<pre><code class="language-bash">dotnet run
</code></pre>
<p>您將看到 Native Function 模擬查詢數據，然後 Semantic Function 利用這些數據生成一份格式化的週報。</p>
<h2>5. Parameters / API Reference</h2>
<p>Semantic Kernel 的核心 API 圍繞著 <code>Kernel</code> 類別及其相關方法，以及用於定義 Functions 的屬性。</p>
<h3>5.1 <code>Kernel</code> 類別核心方法</h3>
<table><thead><tr><th style="text-align:left">方法/屬性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>Kernel.CreateBuilder()</code></td><td style="text-align:left">創建一個 <code>KernelBuilder</code> 實例，用於配置和構建 <code>Kernel</code>。</td></tr><tr><td style="text-align:left"><code>AddOpenAIChatCompletion()</code></td><td style="text-align:left">添加 OpenAI Chat Completion 服務。</td></tr><tr><td style="text-align:left"><code>ImportPluginFromObject()</code></td><td style="text-align:left">從一個 C# 物件導入 Native Functions 作為 Plugin。</td></tr><tr><td style="text-align:left"><code>CreateFunctionFromPrompt()</code></td><td style="text-align:left">從提示詞模板創建一個 Semantic Function。</td></tr><tr><td style="text-align:left"><code>InvokeAsync&lt;T&gt;()</code></td><td style="text-align:left">異步執行一個 Function，並返回指定類型 <code>T</code> 的結果。</td></tr></tbody></table>
<h3>5.2 Native Function 相關屬性</h3>
<table><thead><tr><th style="text-align:left">屬性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>[KernelFunction]</code></td><td style="text-align:left">標記一個 C# 方法為 Kernel 可調用的 Native Function。</td></tr><tr><td style="text-align:left"><code>[Description(string)]</code></td><td style="text-align:left">為 Function 或其參數提供描述，有助於 AI Planner 理解其用途。</td></tr></tbody></table>
<h3>5.3 <code>KernelArguments</code> 類別</h3>
<table><thead><tr><th style="text-align:left">方法/屬性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>new KernelArguments()</code></td><td style="text-align:left">創建一個新的參數集合。</td></tr><tr><td style="text-align:left"><code>Add(key, value)</code></td><td style="text-align:left">添加一個鍵值對，用於在 Functions 之間傳遞數據。</td></tr></tbody></table>
<h2>6. Notes &amp; Best Practices</h2>
<ol>
<li><strong>安全性</strong>：<!-- -->
<ul>
<li><strong>輸入驗證</strong>：對所有傳入 Native Function 的參數進行嚴格的輸入驗證，防止 SQL 注入、路徑遍歷等攻擊。不要盲目信任 AI 生成的參數 [6]。</li>
<li><strong>最小權限原則</strong>：Native Function 存取外部系統（如資料庫、API）時，應使用具有最小必要權限的憑證。</li>
<li><strong>敏感資訊處理</strong>：避免在 Semantic Function 的提示詞中直接包含敏感資訊。如果需要處理敏感數據，應在 Native Function 中進行處理或脫敏。</li>
</ul>
</li>
<li><strong>錯誤處理</strong>：<!-- -->
<ul>
<li>在 Native Function 中實作健壯的錯誤處理機制，捕獲資料庫連接失敗、API 調用錯誤等異常，並向 Kernel 返回清晰的錯誤訊息。</li>
<li>考慮在 Semantic Function 的提示詞中加入錯誤處理指令，指導 LLM 在遇到無效數據時如何回應。</li>
</ul>
</li>
<li><strong>提示詞工程</strong>：<!-- -->
<ul>
<li><strong>清晰明確</strong>：Semantic Function 的提示詞應清晰、明確地指示 LLM 的任務和預期輸出格式（例如 Markdown、JSON）。</li>
<li><strong>Few-shot 範例</strong>：對於複雜的 Semantic Function，提供 Few-shot 範例可以顯著提高 LLM 的輸出品質和一致性。</li>
<li><strong>變數命名</strong>：在提示詞中使用有意義的變數名（例如 <code>{{$input}}</code> 而非 <code>{{$data}}</code>），以提高可讀性。</li>
</ul>
</li>
<li><strong>性能優化</strong>：<!-- -->
<ul>
<li><strong>非同步操作</strong>：Native Function 中涉及 I/O 操作（如資料庫查詢、網路請求）應使用非同步方法，以避免阻塞主執行緒。</li>
<li><strong>快取機制</strong>：對於頻繁查詢且數據變化不大的 Native Function，考慮實作快取機制，減少對後端系統的負載。</li>
</ul>
</li>
<li><strong>模組化與可擴展性</strong>：<!-- -->
<ul>
<li>將相關的 Native Functions 和 Semantic Functions 組織成獨立的 Plugins，提高程式碼的模組化和可重用性。</li>
<li>利用 .NET 的依賴注入（Dependency Injection）機制來管理 Kernel 和 Plugins 的生命週期，方便測試和維護。</li>
</ul>
</li>
</ol>
<h2>7. 為什麼選擇這種方式？</h2>
<p>在構建企業級 AI 應用程式時，混合使用 Semantic Kernel 的 Native Function 與 Semantic Function 是一種極其強大且高效的架構模式，其優勢顯而易見：</p>
<ol>
<li><strong>實現 AI 的「精確」與「智慧」結合</strong>：Native Function 提供了傳統程式碼的精確性、確定性和對外部系統的控制能力，確保了數據獲取和邏輯執行的可靠性。而 Semantic Function 則賦予了應用程式 LLM 的語意理解、內容生成和靈活推理的智慧。兩者結合，使得 AI 應用既能處理複雜的結構化數據，又能生成富有洞察力的自然語言內容 [1]。</li>
<li><strong>提升開發效率與靈活性</strong>：開發者可以將重複性高、邏輯固定的任務封裝為 Native Function，而將需要 LLM 參與的模糊、創意性任務定義為 Semantic Function。這種分工使得開發過程更加高效，同時也提供了極大的靈活性，可以根據業務需求快速調整或替換 Functions [2]。</li>
<li><strong>優化資源利用與成本控制</strong>：將確定性任務交由 Native Function 處理，可以減少對 LLM 的不必要調用，從而降低 LLM API 的使用成本。只有在真正需要語意理解或內容生成時才呼叫 Semantic Function，實現資源的優化配置。</li>
<li><strong>構建可擴展且可維護的 AI 應用</strong>：Semantic Kernel 的 Plugin 和 Function 抽象層，鼓勵模組化設計。這使得應用程式的各個部分可以獨立開發、測試和部署，提高了整體的可擴展性和可維護性。當底層 LLM 模型或資料庫結構發生變化時，只需更新相應的 Function 或 Plugin，而不會影響整個系統 [4]。</li>
<li><strong>充分利用 .NET 生態系統優勢</strong>：對於 .NET 開發者而言，Semantic Kernel 提供了與 C# 和 .NET 9 的深度整合。這意味著可以利用現有的 .NET 工具、庫和開發經驗，快速構建企業級 AI 應用，無需學習全新的技術棧，降低了學習曲線和開發門檻 [7]。</li>
</ol>
<hr/>
<p><strong>參考資料</strong></p>
<ul>
<li>[1] Microsoft Learn. (2024, November 8). <em>How to quickly start with Semantic Kernel</em>. Retrieved from <a href="https://learn.microsoft.com/en-us/semantic-kernel/get-started/quick-start-guide">https://learn.microsoft.com/en-us/semantic-kernel/get-started/quick-start-guide</a></li>
<li>[2] Microsoft Learn. (2024, December 10). <em>Plugins in Semantic Kernel</em>. Retrieved from <a href="https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/">https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/</a></li>
<li>[3] NuGet. (n.d.). <em>Microsoft.SemanticKernel 1.70.0</em>. Retrieved from <a href="https://www.nuget.org/packages/Microsoft.SemanticKernel">https://www.nuget.org/packages/Microsoft.SemanticKernel</a></li>
<li>[4] jamiemaguire.net. (2024, July 5). <em>Semantic Kernel: Implementing Native Functions and Plugins</em>. Retrieved from <a href="https://jamiemaguire.net/index.php/2024/07/05/semantic-kernel-implementing-native-functions-and-plugins/">https://jamiemaguire.net/index.php/2024/07/05/semantic-kernel-implementing-native-functions-and-plugins/</a></li>
<li>[5] GitHub. (n.d.). <em>Chaining native &amp; semantic functions using MS Semantic Kernel</em>. Retrieved from <a href="https://github.com/RobertEichenseer/OpenAI.SemanticNativeFunctions">https://github.com/RobertEichenseer/OpenAI.SemanticNativeFunctions</a></li>
<li>[6] YouTube. (2024, March 5). <em>OpenAI Function Calling with Semantic Kernel, C#, &amp; Entity Framework Core</em>. Retrieved from <a href="https://www.youtube.com/watch?v=4sKRwflEyHk">https://www.youtube.com/watch?v=4sKRwflEyHk</a></li>
<li>[7] Medium. (2025, February 27). <em>Building AI-Powered .NET Applications with Semantic Kernel</em>. Retrieved from <a href="https://medium.com/@aschultzme/building-ai-powered-net-applications-with-semantic-kernel-0cacd0c43877">https://medium.com/@aschultzme/building-ai-powered-net-applications-with-semantic-kernel-0cacd0c43877</a></li>
</ul></div></div></div></div></div></article><!--$--><!--/$--><!--$--><!--/$--></main><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><noscript>You need to enable JavaScript to run this app.</noscript><div class="position-fixed" style="z-index:1050;bottom:20px;right:20px;transform:translate(0px, 0px);touch-action:none;cursor:default;display:flex;flex-direction:column;align-items:flex-end;transition:transform 0.3s ease"><div class="position-relative"><button class="btn rounded-circle d-flex align-items-center justify-content-center shadow-lg" style="width:60px;height:60px;cursor:grab;background:linear-gradient(135deg, #0d6efd, #0a58ca);border:2px solid rgba(255,255,255,0.2);transition:transform 0.2s ease" aria-label="切換聊天視窗"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="white" style="width:28px;height:28px;pointer-events:none"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"></path></svg></button><span class="position-absolute bg-danger rounded-circle" style="width:12px;height:12px;top:0;right:0;border:2px solid white"></span></div></div><script src="https://qwer820921.github.io/_next/static/chunks/webpack-40d0a3f2167e9bf7.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[69243,[\"6283\",\"static/chunks/6283-1586b7e20e5a28d4.js\",\"7177\",\"static/chunks/app/layout-984d35e9d146542e.js\"],\"\"]\n3:I[6476,[\"6283\",\"static/chunks/6283-1586b7e20e5a28d4.js\",\"7177\",\"static/chunks/app/layout-984d35e9d146542e.js\"],\"default\"]\n4:I[87555,[],\"\"]\n5:I[31295,[],\"\"]\n6:I[39543,[\"6283\",\"static/chunks/6283-1586b7e20e5a28d4.js\",\"7177\",\"static/chunks/app/layout-984d35e9d146542e.js\"],\"default\"]\n8:I[59665,[],\"MetadataBoundary\"]\na:I[59665,[],\"OutletBoundary\"]\nd:I[74911,[],\"AsyncMetadataOutlet\"]\nf:I[59665,[],\"ViewportBoundary\"]\n11:I[26614,[],\"\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/f71b761575b48bd6.css\",\"style\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/e57a9f01512809bb.css\",\"style\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/4bb1c53d4d41ca49.css\",\"style\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/45df6ee84bc085cd.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"Ec9_WQwGV0Qs9AuUIHOZB\",\"p\":\"https://qwer820921.github.io\",\"c\":[\"\",\"blog\",\"hybrid-functions-with-semantic-kernel\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"hybrid-functions-with-semantic-kernel\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/f71b761575b48bd6.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/e57a9f01512809bb.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/4bb1c53d4d41ca49.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-Hant\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.ico\"}],[\"$\",\"link\",null,{\"rel\":\"apple-touch-icon\",\"href\":\"/logo192.png\"}],[\"$\",\"link\",null,{\"rel\":\"manifest\",\"href\":\"/manifest.json\"}],[\"$\",\"link\",null,{\"rel\":\"preload\",\"href\":\"/logo192.png\",\"as\":\"image\"}],[\"$\",\"$L2\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-CCKVESHCQ1\"}],[\"$\",\"$L2\",null,{\"id\":\"google-analytics\",\"children\":\"\\n            window.dataLayer = window.dataLayer || [];\\n            function gtag(){dataLayer.push(arguments);}\\n            gtag('js', new Date());\\n            gtag('config', 'G-CCKVESHCQ1');\\n          \"}],[\"$\",\"$L2\",null,{\"async\":true,\"src\":\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2709303513603814\",\"crossOrigin\":\"anonymous\"}]]}],[\"$\",\"body\",null,{\"children\":[[\"$\",\"$L3\",null,{\"children\":[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"$L6\",null,{}]]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"hybrid-functions-with-semantic-kernel\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/45df6ee84bc085cd.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"7_QuoWN5X-RsW9fL5TMmY\",{\"children\":[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],null]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"12:\"$Sreact.suspense\"\n13:I[74911,[],\"AsyncMetadata\"]\n9:[\"$\",\"$12\",null,{\"fallback\":null,\"children\":[\"$\",\"$L13\",null,{\"promise\":\"$@14\"}]}]\n"])</script><script>self.__next_f.push([1,"15:I[57113,[\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-625d55d419426b5e.js\"],\"default\"]\nc:null\n7:[\"$\",\"article\",null,{\"className\":\"container py-5\",\"children\":[[\"$\",\"div\",null,{\"className\":\"row justify-content-center\",\"children\":[\"$\",\"div\",null,{\"className\":\"col-12 col-lg-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"card blogPost_articleCard__LIiRr\",\"children\":[\"$\",\"div\",null,{\"className\":\"card-body blogPost_cardBody__5xHPD\",\"children\":[[\"$\",\"header\",null,{\"className\":\"blogPost_articleHeader__dQ5vG\",\"children\":[[\"$\",\"$L15\",null,{\"mode\":\"static\",\"id\":\"static-back-btn\"}],[\"$\",\"h1\",null,{\"className\":\"blogPost_articleTitle__BCXQE\",\"children\":\"【架構設計】Semantic Kernel 實戰：混合使用 Native Function 與 Semantic Function\"}],[\"$\",\"div\",null,{\"className\":\"blogPost_articleMeta__1R_wB\",\"children\":[[\"$\",\"div\",null,{\"className\":\"blogPost_metaItem__xpKuj\",\"children\":[[\"$\",\"i\",null,{\"className\":\"bi bi-person-fill blogPost_metaIcon__h8wBb\"}],[\"$\",\"span\",null,{\"className\":\"blogPost_metaLabel__y0uVD\",\"children\":\"作者:\"}],\"子yee\"]}],[\"$\",\"div\",null,{\"className\":\"blogPost_metaItem__xpKuj\",\"children\":[[\"$\",\"i\",null,{\"className\":\"bi bi-calendar3 blogPost_metaIcon__h8wBb\"}],[\"$\",\"span\",null,{\"className\":\"blogPost_metaLabel__y0uVD\",\"children\":\"日期:\"}],\"2026-02-06\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"blogContent_blogContent__VY_R4\",\"children\":\"$L16\"}]]}]}]}]}],[\"$\",\"$L15\",null,{\"mode\":\"floating\",\"targetId\":\"static-back-btn\"}]]}]\n"])</script><script>self.__next_f.push([1,"17:T644,using Microsoft.SemanticKernel;\nusing System.ComponentModel;\nusing System.Text.Json;\n\npublic class SalesDataPlugin\n{\n    [KernelFunction, Description(\"從資料庫獲取指定日期範圍內的銷售數據。\")]\n    public async Task\u003cstring\u003e GetWeeklySalesData(\n        [Description(\"開始日期，格式為 YYYY-MM-DD\")] string startDate,\n        [Description(\"結束日期，格式為 YYYY-MM-DD\")] string endDate)\n    {\n        // 模擬從 SQL Server 查詢數據\n        // 在實際應用中，這裡會是真實的資料庫查詢邏輯\n        Console.WriteLine($\"\\n[Native Function] 正在從資料庫獲取 {startDate} 到 {endDate} 的銷售數據...\");\n\n        // 模擬數據庫查詢結果\n        var salesData = new List\u003cobject\u003e\n        {\n            new { Product = \"筆記型電腦\", Quantity = 150, Revenue = 150000.00, Date = \"2026-02-03\" },\n            new { Product = \"智慧型手機\", Quantity = 200, Revenue = 120000.00, Date = \"2026-02-04\" },\n            new { Product = \"平板電腦\", Quantity = 80, Revenue = 40000.00, Date = \"2026-02-05\" },\n            new { Product = \"智慧手錶\", Quantity = 300, Revenue = 60000.00, Date = \"2026-02-06\" },\n            new { Product = \"耳機\", Quantity = 500, Revenue = 25000.00, Date = \"2026-02-07\" }\n        };\n\n        await Task.Delay(500); // 模擬網路延遲\n\n        var jsonOptions = new JsonSerializerOptions { WriteIndented = true };\n        string jsonResult = JsonSerializer.Serialize(salesData, jsonOptions);\n        Console.WriteLine(\"[Native Function] 銷售數據獲取完成。\");\n        return jsonResult;\n    }\n}\n18:Ta85,"])</script><script>self.__next_f.push([1,"using Microsoft.SemanticKernel;\nusing Microsoft.SemanticKernel.Connectors.OpenAI;\nusing Microsoft.Extensions.Configuration;\nusing System.Text.Json;\n\npublic class Program\n{\n    public static async Task Main(string[] args)\n    {\n        // 1. 配置 Kernel\n        var configuration = new ConfigurationBuilder()\n            .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true)\n            .AddEnvironmentVariables()\n            .Build();\n\n        var builder = Kernel.CreateBuilder();\n\n        // 根據配置添加 LLM 服務\n        if (configuration[\"OpenAI:ApiKey\"] is string openAIApiKey \u0026\u0026 !string.IsNullOrEmpty(openAIApiKey))\n        {\n            builder.AddOpenAIChatCompletion(\n                modelId: configuration[\"OpenAI:ModelId\"] ?? \"gpt-4o\",\n                apiKey: openAIApiKey);\n        }\n        else\n        {\n            Console.WriteLine(\"請在 appsettings.json 或環境變數中配置 OpenAI:ApiKey。\");\n            return;\n        }\n\n        Kernel kernel = builder.Build();\n\n        // 2. 導入 Native Function Plugin\n        kernel.ImportPluginFromObject(new SalesDataPlugin(), \"SalesDataPlugin\");\n        Console.WriteLine(\"Native Function Plugin 'SalesDataPlugin' 導入成功。\");\n\n        // 3. 創建 Semantic Function\n        var generateReportFunction = kernel.CreateFunctionFromPrompt(\n            ReportPlugin.GenerateWeeklyReportPrompt,\n            functionName: \"GenerateWeeklyReport\",\n            description: \"根據銷售數據生成週報\"\n        );\n        Console.WriteLine(\"Semantic Function 'GenerateWeeklyReport' 創建成功。\");\n\n        // 4. 定義日期範圍\n        string startDate = \"2026-02-03\";\n        string endDate = \"2026-02-07\";\n\n        // 5. 執行工作流：Native Function -\u003e Semantic Function\n        Console.WriteLine(\"\\n--- 開始生成週報工作流 ---\");\n\n        // 步驟 1: 呼叫 Native Function 獲取銷售數據\n        var salesDataJson = await kernel.InvokeAsync\u003cstring\u003e(\n            \"SalesDataPlugin\",\n            \"GetWeeklySalesData\",\n            new KernelArguments { { \"startDate\", startDate }, { \"endDate\", endDate } }\n        );\n\n        Console.WriteLine(\"\\n[Main] 獲取到的銷售數據 (JSON):\\n\" + salesDataJson);\n\n        // 步驟 2: 呼叫 Semantic Function 生成報告\n        var report = await kernel.InvokeAsync\u003cstring\u003e(\n            generateReportFunction,\n            new KernelArguments { { \"input\", salesDataJson } } // 將 Native Function 的輸出作為 Semantic Function 的輸入\n        );\n\n        Console.WriteLine(\"\\n--- 生成的週報 ---\");\n        Console.WriteLine(report);\n\n        Console.WriteLine(\"\\n--- 週報生成工作流完成 ---\");\n    }\n}\n"])</script><script>self.__next_f.push([1,"16:[[\"$\",\"h2\",null,{\"children\":\"1. Overview\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"隨著生成式 AI 技術的快速發展，將大型語言模型（LLM）的能力整合到傳統應用程式中，已成為現代軟體開發的趨勢。然而，LLM 擅長處理非結構化數據、理解語意和生成創意內容，卻不擅長執行精確的邏輯運算、存取外部系統或處理大量結構化數據。為了解決這個問題，Microsoft 推出了 \",[\"$\",\"strong\",null,{\"children\":\"Semantic Kernel (SK)\"}],\" 框架，它提供了一個輕量級的 SDK，旨在將 LLM 與傳統程式語言（如 C#, Python, Java）無縫結合，讓開發者能夠構建出既具備 AI 智慧又擁有確定性邏輯的應用程式 [1]。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Semantic Kernel 的核心概念之一是將應用程式的能力抽象為 \",[\"$\",\"strong\",null,{\"children\":\"Skills\"}],\"，而每個 Skill 又由一個或多個 \",[\"$\",\"strong\",null,{\"children\":\"Functions\"}],\" 組成。這些 Functions 主要分為兩大類：\"]}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Native Function (原生技能)\"}],\"：由傳統程式語言（例如 C#）編寫，負責執行確定性的、邏輯嚴謹的任務，如查詢資料庫、呼叫外部 API、執行複雜計算等。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Semantic Function (語意技能)\"}],\"：由提示詞（Prompt）定義，利用 LLM 的能力來處理語意理解、內容生成、摘要或格式轉換等任務。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"本文件將深入探討 Semantic Kernel 在 .NET 9 環境下的核心架構，並透過實戰範例，演示如何巧妙地將 Native Function 與 Semantic Function 串聯（Chain）起來，讓 AI 能夠先透過 Native Function 從資料庫中獲取精確的結構化數據，再利用 Semantic Function 將這些數據轉化為易讀、富有洞察力的報告。這種混合使用模式，將極大提升 AI 應用程式的實用性、精確性和自動化程度。\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"2. Architecture / Design\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Semantic Kernel 的設計哲學是將 LLM 視為一個強大的推理引擎，而 Native Functions 則為這個引擎提供了與真實世界互動的「手腳」。透過將這些能力組織成 Plugins 和 Functions，並由 Kernel 進行協調，我們可以構建出高度智能且可靠的 AI 應用程式 [2]。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"2.1 Semantic Kernel 核心組件\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Semantic Kernel 的核心架構圍繞著以下幾個關鍵組件：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Kernel\"}],\"：這是 Semantic Kernel 的核心引擎，負責協調所有 Functions 的執行。它管理 Plugins、Functions、記憶體（Memory）和 LLM 服務的連接。開發者透過 \",[\"$\",\"code\",null,{\"children\":\"Kernel\"}],\" 實例來執行 AI 任務 [3]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Plugins (技能集)\"}],\"：Plugins 是相關 Functions 的集合。一個 Plugin 可以包含多個 Native Functions 和 Semantic Functions。例如，一個 \",[\"$\",\"code\",null,{\"children\":\"DatabasePlugin\"}],\" 可能包含 \",[\"$\",\"code\",null,{\"children\":\"GetSalesData\"}],\" (Native) 和 \",[\"$\",\"code\",null,{\"children\":\"SummarizeData\"}],\" (Semantic) [4]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Native Function (原生技能)\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"定義\"}],\"：使用 C# 等傳統程式語言編寫的函數。它們是確定性的，執行傳統的程式邏輯。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"職責\"}],\"：主要用於執行需要精確控制、外部系統互動或大量數據處理的任務，例如：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"查詢 SQL 資料庫或 NoSQL 資料庫。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"呼叫 RESTful API 或 gRPC 服務。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"執行檔案讀寫操作。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"進行複雜的數學計算或數據轉換。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"優點\"}],\"：結果確定、效能高、可進行完整的單元測試和整合測試。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Semantic Function (語意技能)\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"定義\"}],\"：由一個或多個提示詞模板（Prompt Template）定義，利用 LLM 的能力來完成任務。它們是非確定性的，結果會因 LLM 的生成能力而異。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"職責\"}],\"：主要用於處理需要語意理解、內容生成或格式轉換的任務，例如：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"總結長篇文本。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"根據數據生成自然語言報告。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"將 JSON 數據轉換為易讀的 Markdown 格式。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"進行情感分析或意圖識別。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"優點\"}],\"：處理模糊需求能力強、開發速度快、可快速迭代。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"KernelArguments\"}],\"：這是一個用於在 Functions 之間傳遞狀態和參數的物件。它類似於一個字典，可以儲存多個鍵值對，供不同的 Functions 讀取和寫入 [5]。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"2.2 混合工作流設計：Native + Semantic Function 串聯\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"本文件的核心目標是演示如何將 Native Function 與 Semantic Function 串聯起來，構建一個從資料庫查詢到報告生成的自動化工作流。以下是一個典型的串聯邏輯：\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"使用者輸入 (User Input)\"}],\"：使用者向 AI 應用程式提出一個高層次的需求，例如：「請生成上週的銷售數據週報。」\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"AI 意圖識別與規劃 (AI Intent Recognition \u0026 Planning)\"}],\"：如果應用程式使用了 Planner（規劃器），AI 會分析使用者意圖，並自動規劃出一個執行計畫，決定需要呼叫哪些 Functions 以及它們的順序。即使沒有 Planner，開發者也可以手動編排 Functions 的執行順序。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Native Function 執行 (Data Retrieval)\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"首先，Kernel 會呼叫一個 Native Function，例如 \",[\"$\",\"code\",null,{\"children\":\"SalesDataPlugin.GetWeeklySalesData(startDate, endDate)\"}],\"。這個 Native Function 會連接到後端 SQL Server 資料庫，執行一個精確的 SQL 查詢，獲取上週的銷售數據。數據通常以結構化的 JSON 格式返回。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"Native Function 將查詢到的 JSON 數據儲存到 \",[\"$\",\"code\",null,{\"children\":\"KernelArguments\"}],\" 中，作為後續 Functions 的輸入。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Semantic Function 執行 (Report Generation)\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"接著，Kernel 會呼叫一個 Semantic Function，例如 \",[\"$\",\"code\",null,{\"children\":\"ReportPlugin.GenerateWeeklyReport(salesDataJson)\"}],\"。這個 Semantic Function 的提示詞模板會被設計成接收 JSON 格式的銷售數據，並指示 LLM 將其轉化為一份易讀、摘要性的週報（例如 Markdown 格式）。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"LLM 根據提示詞和 \",[\"$\",\"code\",null,{\"children\":\"KernelArguments\"}],\" 中提供的銷售數據，生成最終的週報內容。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"輸出呈現 (Output Presentation)\"}],\"：應用程式將 LLM 生成的週報內容呈現給使用者。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"這種串聯模式充分利用了 Native Function 的精確性和 Semantic Function 的語意理解能力，實現了數據驅動的智能內容生成。\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"3. Prerequisites\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"要實作 Semantic Kernel 應用程式，特別是結合 Native Function 與 Semantic Function，您需要具備以下環境和知識：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\".NET 9 SDK\"}],\"：確保您的開發環境已安裝 .NET 9 SDK 或更高版本。Semantic Kernel 與 .NET 生態系統緊密整合。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"C# 程式設計知識\"}],\"：熟悉 C# 語言特性、非同步程式設計（\",[\"$\",\"code\",null,{\"children\":\"async/await\"}],\"）和物件導向程式設計。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"LLM 服務\"}],\"：需要一個可用的 LLM 服務，例如 Azure OpenAI Service、OpenAI API 或其他支援的 LLM 提供商。您需要相應的 API 金鑰和端點。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Semantic Kernel NuGet 套件\"}],\"：安裝 \",[\"$\",\"code\",null,{\"children\":\"Microsoft.SemanticKernel\"}],\" 及其相關套件。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"資料庫知識\"}],\"：如果 Native Function 需要與資料庫互動，您需要了解 SQL Server 或其他資料庫的基本操作。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Visual Studio 或 VS Code\"}],\"：推薦使用這些 IDE 進行 .NET 開發。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"4. Implementation / Code Example\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"本節將提供一個使用 C# 和 .NET 9 實作 Semantic Kernel 混合 Native Function 與 Semantic Function 的範例。我們將模擬一個從資料庫獲取銷售數據，然後生成週報的場景。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.1 專案初始化\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"首先，創建一個新的 .NET Console 專案並安裝必要的 NuGet 套件：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-bash\",\"children\":\"dotnet new console -n SemanticKernelHybridDemo\\ncd SemanticKernelHybridDemo\\ndotnet add package Microsoft.SemanticKernel\\ndotnet add package Microsoft.SemanticKernel.Connectors.OpenAI # 根據您使用的 LLM 選擇連接器\\ndotnet add package Microsoft.Extensions.Configuration.Json # 用於配置管理\\ndotnet add package Microsoft.Extensions.Configuration.EnvironmentVariables\\ndotnet add package System.Data.SqlClient # 模擬 SQL Server 連接\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.2 配置 LLM 服務\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"創建 \",[\"$\",\"code\",null,{\"children\":\"appsettings.json\"}],\" 檔案來儲存您的 LLM 服務配置：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-json\",\"children\":\"{\\n  \\\"OpenAI\\\": {\\n    \\\"ModelId\\\": \\\"gpt-4o\\\",\\n    \\\"ApiKey\\\": \\\"YOUR_OPENAI_API_KEY\\\"\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"或者使用環境變數來儲存 \",[\"$\",\"code\",null,{\"children\":\"OPENAI_API_KEY\"}],\"。\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.3 定義 Native Function (SalesDataPlugin.cs)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"這個 Native Function 模擬從 SQL Server 獲取銷售數據。在實際應用中，這裡會使用 Entity Framework Core 或 ADO.NET 進行真實的資料庫操作。\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-csharp\",\"children\":\"$17\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.4 定義 Semantic Function (ReportPlugin)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Semantic Function 通常由一個提示詞模板文件 (\",[\"$\",\"code\",null,{\"children\":\"skprompt.txt\"}],\") 和一個配置文件 (\",[\"$\",\"code\",null,{\"children\":\"config.json\"}],\") 組成。為了簡化範例，我們直接在程式碼中定義提示詞。\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-csharp\",\"children\":\"// ReportPlugin.cs (或直接在 Program.cs 中定義)\\n\\npublic static class ReportPlugin\\n{\\n    public static string GenerateWeeklyReportPrompt = @\\\"\\n    你是一個專業的商業分析師，請根據提供的 JSON 格式銷售數據，生成一份簡潔、易讀的週報。\\n    週報應包含以下部分：\\n    1. 總銷售額和總銷售量。\\n    2. 表現最佳的產品（銷售額最高）。\\n    3. 任何值得注意的趨勢或觀察。\\n\\n    請以 Markdown 格式輸出報告。\\n\\n    銷售數據 (JSON 格式):\\n    {{$input}}\\n\\n    週報:\\n    \\\";\\n}\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.5 串聯 Native 與 Semantic Function (Program.cs)\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-csharp\",\"children\":\"$18\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.6 運行專案\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"確保您的 \",[\"$\",\"code\",null,{\"children\":\"appsettings.json\"}],\" 中的 \",[\"$\",\"code\",null,{\"children\":\"OpenAI:ApiKey\"}],\" 已正確配置，然後運行：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-bash\",\"children\":\"dotnet run\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"您將看到 Native Function 模擬查詢數據，然後 Semantic Function 利用這些數據生成一份格式化的週報。\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"5. Parameters / API Reference\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Semantic Kernel 的核心 API 圍繞著 \",[\"$\",\"code\",null,{\"children\":\"Kernel\"}],\" 類別及其相關方法，以及用於定義 Functions 的屬性。\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"5.1 \",[\"$\",\"code\",null,{\"children\":\"Kernel\"}],\" 類別核心方法\"]}],\"\\n\",[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"方法/屬性\"}],[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"描述\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"Kernel.CreateBuilder()\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"創建一個 \",[\"$\",\"code\",null,{\"children\":\"KernelBuilder\"}],\" 實例，用於配置和構建 \",[\"$\",\"code\",null,{\"children\":\"Kernel\"}],\"。\"]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"AddOpenAIChatCompletion()\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"添加 OpenAI Chat Completion 服務。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"ImportPluginFromObject()\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"從一個 C# 物件導入 Native Functions 作為 Plugin。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"CreateFunctionFromPrompt()\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"從提示詞模板創建一個 Semantic Function。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"InvokeAsync\u003cT\u003e()\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"異步執行一個 Function，並返回指定類型 \",[\"$\",\"code\",null,{\"children\":\"T\"}],\" 的結果。\"]}]]}]]}]]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"5.2 Native Function 相關屬性\"}],\"\\n\",[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"屬性\"}],[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"描述\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"[KernelFunction]\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"標記一個 C# 方法為 Kernel 可調用的 Native Function。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"[Description(string)]\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"為 Function 或其參數提供描述，有助於 AI Planner 理解其用途。\"}]]}]]}]]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"5.3 \",[\"$\",\"code\",null,{\"children\":\"KernelArguments\"}],\" 類別\"]}],\"\\n\",[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"方法/屬性\"}],[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"描述\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"new KernelArguments()\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"創建一個新的參數集合。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"Add(key, value)\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"添加一個鍵值對，用於在 Functions 之間傳遞數據。\"}]]}]]}]]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"6. Notes \u0026 Best Practices\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"安全性\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"輸入驗證\"}],\"：對所有傳入 Native Function 的參數進行嚴格的輸入驗證，防止 SQL 注入、路徑遍歷等攻擊。不要盲目信任 AI 生成的參數 [6]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"最小權限原則\"}],\"：Native Function 存取外部系統（如資料庫、API）時，應使用具有最小必要權限的憑證。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"敏感資訊處理\"}],\"：避免在 Semantic Function 的提示詞中直接包含敏感資訊。如果需要處理敏感數據，應在 Native Function 中進行處理或脫敏。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"錯誤處理\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"在 Native Function 中實作健壯的錯誤處理機制，捕獲資料庫連接失敗、API 調用錯誤等異常，並向 Kernel 返回清晰的錯誤訊息。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"考慮在 Semantic Function 的提示詞中加入錯誤處理指令，指導 LLM 在遇到無效數據時如何回應。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"提示詞工程\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"清晰明確\"}],\"：Semantic Function 的提示詞應清晰、明確地指示 LLM 的任務和預期輸出格式（例如 Markdown、JSON）。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Few-shot 範例\"}],\"：對於複雜的 Semantic Function，提供 Few-shot 範例可以顯著提高 LLM 的輸出品質和一致性。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"變數命名\"}],\"：在提示詞中使用有意義的變數名（例如 \",[\"$\",\"code\",null,{\"children\":\"{{$input}}\"}],\" 而非 \",[\"$\",\"code\",null,{\"children\":\"{{$data}}\"}],\"），以提高可讀性。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"性能優化\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"非同步操作\"}],\"：Native Function 中涉及 I/O 操作（如資料庫查詢、網路請求）應使用非同步方法，以避免阻塞主執行緒。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"快取機制\"}],\"：對於頻繁查詢且數據變化不大的 Native Function，考慮實作快取機制，減少對後端系統的負載。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"模組化與可擴展性\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"將相關的 Native Functions 和 Semantic Functions 組織成獨立的 Plugins，提高程式碼的模組化和可重用性。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"利用 .NET 的依賴注入（Dependency Injection）機制來管理 Kernel 和 Plugins 的生命週期，方便測試和維護。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"7. 為什麼選擇這種方式？\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"在構建企業級 AI 應用程式時，混合使用 Semantic Kernel 的 Native Function 與 Semantic Function 是一種極其強大且高效的架構模式，其優勢顯而易見：\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"實現 AI 的「精確」與「智慧」結合\"}],\"：Native Function 提供了傳統程式碼的精確性、確定性和對外部系統的控制能力，確保了數據獲取和邏輯執行的可靠性。而 Semantic Function 則賦予了應用程式 LLM 的語意理解、內容生成和靈活推理的智慧。兩者結合，使得 AI 應用既能處理複雜的結構化數據，又能生成富有洞察力的自然語言內容 [1]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"提升開發效率與靈活性\"}],\"：開發者可以將重複性高、邏輯固定的任務封裝為 Native Function，而將需要 LLM 參與的模糊、創意性任務定義為 Semantic Function。這種分工使得開發過程更加高效，同時也提供了極大的靈活性，可以根據業務需求快速調整或替換 Functions [2]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"優化資源利用與成本控制\"}],\"：將確定性任務交由 Native Function 處理，可以減少對 LLM 的不必要調用，從而降低 LLM API 的使用成本。只有在真正需要語意理解或內容生成時才呼叫 Semantic Function，實現資源的優化配置。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"構建可擴展且可維護的 AI 應用\"}],\"：Semantic Kernel 的 Plugin 和 Function 抽象層，鼓勵模組化設計。這使得應用程式的各個部分可以獨立開發、測試和部署，提高了整體的可擴展性和可維護性。當底層 LLM 模型或資料庫結構發生變化時，只需更新相應的 Function 或 Plugin，而不會影響整個系統 [4]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"充分利用 .NET 生態系統優勢\"}],\"：對於 .NET 開發者而言，Semantic Kernel 提供了與 C# 和 .NET 9 的深度整合。這意味著可以利用現有的 .NET 工具、庫和開發經驗，快速構建企業級 AI 應用，無需學習全新的技術棧，降低了學習曲線和開發門檻 [7]。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"參考資料\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[1] Microsoft Learn. (2024, November 8). \",[\"$\",\"em\",null,{\"children\":\"How to quickly start with Semantic Kernel\"}],\". Retrieved from \",[\"$\",\"a\",null,{\"href\":\"https://learn.microsoft.com/en-us/semantic-kernel/get-started/quick-start-guide\",\"children\":\"https://learn.microsoft.com/en-us/semantic-kernel/get-started/quick-start-guide\"}]]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[2] Microsoft Learn. (2024, December 10). \",[\"$\",\"em\",null,{\"children\":\"Plugins in Semantic Kernel\"}],\". Retrieved from \",[\"$\",\"a\",null,{\"href\":\"https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/\",\"children\":\"https://learn.microsoft.com/en-us/semantic-kernel/concepts/plugins/\"}]]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[3] NuGet. (n.d.). \",[\"$\",\"em\",null,{\"children\":\"Microsoft.SemanticKernel 1.70.0\"}],\". Retrieved from \",[\"$\",\"a\",null,{\"href\":\"https://www.nuget.org/packages/Microsoft.SemanticKernel\",\"children\":\"https://www.nuget.org/packages/Microsoft.SemanticKernel\"}]]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[4] jamiemaguire.net. (2024, July 5). \",[\"$\",\"em\",null,{\"children\":\"Semantic Kernel: Implementing Native Functions and Plugins\"}],\". Retrieved from \",[\"$\",\"a\",null,{\"href\":\"https://jamiemaguire.net/index.php/2024/07/05/semantic-kernel-implementing-native-functions-and-plugins/\",\"children\":\"https://jamiemaguire.net/index.php/2024/07/05/semantic-kernel-implementing-native-functions-and-plugins/\"}]]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[5] GitHub. (n.d.). \",[\"$\",\"em\",null,{\"children\":\"Chaining native \u0026 semantic functions using MS Semantic Kernel\"}],\". Retrieved from \",[\"$\",\"a\",null,{\"href\":\"https://github.com/RobertEichenseer/OpenAI.SemanticNativeFunctions\",\"children\":\"https://github.com/RobertEichenseer/OpenAI.SemanticNativeFunctions\"}]]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[6] YouTube. (2024, March 5). \",[\"$\",\"em\",null,{\"children\":\"OpenAI Function Calling with Semantic Kernel, C#, \u0026 Entity Framework Core\"}],\". Retrieved from \",[\"$\",\"a\",null,{\"href\":\"https://www.youtube.com/watch?v=4sKRwflEyHk\",\"children\":\"https://www.youtube.com/watch?v=4sKRwflEyHk\"}]]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[7] Medium. (2025, February 27). \",[\"$\",\"em\",null,{\"children\":\"Building AI-Powered .NET Applications with Semantic Kernel\"}],\". Retrieved from \",[\"$\",\"a\",null,{\"href\":\"https://medium.com/@aschultzme/building-ai-powered-net-applications-with-semantic-kernel-0cacd0c43877\",\"children\":\"https://medium.com/@aschultzme/building-ai-powered-net-applications-with-semantic-kernel-0cacd0c43877\"}]]}],\"\\n\"]}]]\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"14:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"【架構設計】Semantic Kernel 實戰：混合使用 Native Function 與 Semantic Function | 子yee 萬事屋 | 子yee\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"深入探討 Microsoft Semantic Kernel 框架，教學如何在 .NET 9 環境下，將 C# 原生程式碼 (Native Function) 與 LLM 語意邏輯 (Semantic Function) 巧妙結合，實現強大的 AI 應用。\"}],[\"$\",\"meta\",\"2\",{\"name\":\"author\",\"content\":\"子yee\"}],[\"$\",\"meta\",\"3\",{\"name\":\"keywords\",\"content\":\"子yee 萬事屋, 台股查詢, 自選股, 技術小工具, 股票資訊平台, 技術顧問, 自動化工具\"}],[\"$\",\"meta\",\"4\",{\"name\":\"google-site-verification\",\"content\":\"adHIcDQiasHY4YzPlrpmSSPKl7Oj1WxrPJ_4GV4PQcM\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:title\",\"content\":\"【架構設計】Semantic Kernel 實戰：混合使用 Native Function 與 Semantic Function\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:description\",\"content\":\"深入探討 Microsoft Semantic Kernel 框架，教學如何在 .NET 9 環境下，將 C# 原生程式碼 (Native Function) 與 LLM 語意邏輯 (Semantic Function) 巧妙結合，實現強大的 AI 應用。\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image\",\"content\":\"https://qwer820921.github.io/images/img15.jpg\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:image:height\",\"content\":\"630\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:image:alt\",\"content\":\"【架構設計】Semantic Kernel 實戰：混合使用 Native Function 與 Semantic Function\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:title\",\"content\":\"【架構設計】Semantic Kernel 實戰：混合使用 Native Function 與 Semantic Function\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:description\",\"content\":\"深入探討 Microsoft Semantic Kernel 框架，教學如何在 .NET 9 環境下，將 C# 原生程式碼 (Native Function) 與 LLM 語意邏輯 (Semantic Function) 巧妙結合，實現強大的 AI 應用。\"}],[\"$\",\"meta\",\"15\",{\"name\":\"twitter:image\",\"content\":\"https://qwer820921.github.io/images/img15.jpg\"}],[\"$\",\"link\",\"16\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"e:{\"metadata\":\"$14:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>