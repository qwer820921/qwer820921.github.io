<!DOCTYPE html><html lang="zh-Hant"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/be607b33620c6e00.css" data-precedence="next"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/739e5c607d9731d5.css" data-precedence="next"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/4bb1c53d4d41ca49.css" data-precedence="next"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/0105f7c97f16220d.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="https://qwer820921.github.io/_next/static/chunks/webpack-97372da6a069f2e6.js"/><script src="https://qwer820921.github.io/_next/static/chunks/4bd1b696-e100a0b1879d5e6b.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/1684-9b53760636e10952.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/main-app-c0d2570cf703bee2.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/8482-5637f60b9e0ae224.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/app/layout-898a3761c5f29253.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/6874-cfa829be98f8140c.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/app/blog/%5Bslug%5D/page-c93c0e23c9658930.js" async=""></script><link rel="preload" href="https://qwer820921.github.io/_next/static/chunks/2990.dad4388d14b132db.js" as="script" fetchPriority="low"/><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-CCKVESHCQ1" as="script"/><link rel="preload" href="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2709303513603814" as="script" crossorigin=""/><link rel="icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/logo192.png"/><link rel="manifest" href="/manifest.json"/><link rel="preload" href="/logo192.png" as="image"/><title>【提示工程終結者】從 Prompt Engineering 轉向 DSPy (Declarative Self-improving Python) | 子yee 萬事屋 | 子yee</title><meta name="description" content="深入解析 DSPy 框架如何透過宣告式程式設計與自動優化機制，徹底改變 LLM 應用開發範式，告別手寫 Prompt 的脆弱性。"/><meta name="keywords" content="子yee 萬事屋, 台股查詢, 自選股, 技術小工具, 股票資訊平台, 技術顧問, 自動化工具"/><meta name="google-site-verification" content="adHIcDQiasHY4YzPlrpmSSPKl7Oj1WxrPJ_4GV4PQcM"/><meta property="og:title" content="【提示工程終結者】從 Prompt Engineering 轉向 DSPy (Declarative Self-improving Python)"/><meta property="og:description" content="深入解析 DSPy 框架如何透過宣告式程式設計與自動優化機制，徹底改變 LLM 應用開發範式，告別手寫 Prompt 的脆弱性。"/><meta property="og:image" content="https://qwer820921.github.io/images/img15.jpg"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:alt" content="【提示工程終結者】從 Prompt Engineering 轉向 DSPy (Declarative Self-improving Python)"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="【提示工程終結者】從 Prompt Engineering 轉向 DSPy (Declarative Self-improving Python)"/><meta name="twitter:description" content="深入解析 DSPy 框架如何透過宣告式程式設計與自動優化機制，徹底改變 LLM 應用開發範式，告別手寫 Prompt 的脆弱性。"/><meta name="twitter:image" content="https://qwer820921.github.io/images/img15.jpg"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="https://qwer820921.github.io/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><main class="container-fluid mt-5 p-0"><article class="container py-5"><div class="row justify-content-center"><div class="col-12 col-lg-8"><div class="mb-4"><a class="btn btn-outline-secondary d-inline-flex align-items-center gap-2" href="/blog"><span>←</span>回到文章列表</a></div><div class="card shadow-sm border-0"><div class="card-body p-4 p-md-5"><header class="mb-5 pb-4 border-bottom"><h1 class="fw-bold mb-3 display-5">【提示工程終結者】從 Prompt Engineering 轉向 DSPy (Declarative Self-improving Python)</h1><div class="text-muted d-flex align-items-center gap-2"><i class="bi bi-calendar3"></i>2026-02-12</div></header><div class="blogContent_blogContent__VY_R4"><h1>【提示工程終結者】從 Prompt Engineering 轉向 DSPy (Declarative Self-improving Python)</h1>
<p><strong>作者：</strong> Manus AI
<strong>日期：</strong> 2026年2月11日</p>
<hr/>
<h2>1. Overview</h2>
<p>在大型語言模型（LLM）應用開發的早期階段，「提示工程（Prompt Engineering）」是核心技能。開發者花費大量時間精心設計、迭代和微調提示詞（Prompt），以引導 LLM 產生期望的輸出。然而，這種手動的提示詞工程方法存在顯著的局限性：它<strong>脆弱</strong>、<strong>難以維護</strong>、<strong>難以擴展</strong>，且<strong>缺乏系統性</strong> [1]。當底層 LLM 模型更新、任務需求變化或需要遷移到不同模型時，手寫的提示詞往往會失效，導致巨大的維護成本。</p>
<p>進入 2026 年，業界對 LLM 應用開發的觀點已發生根本性轉變：「手寫 Prompt 是脆弱的」。由史丹佛大學提出的 <strong>DSPy (Declarative Self-improving Python)</strong> 框架，正是為了解決這一痛點而生。DSPy 允許開發者以宣告式（Declarative）的方式定義 LLM 應用程式的邏輯和任務模組，而不是直接編寫提示詞。它將提示詞的生成與優化交給了自動化的「編譯器（Compiler）」和「優化器（Optimizer）」，這些工具能夠透過少量的數據集，自動迭代出比人類手寫更強大、更穩健的提示詞結構 [2]。</p>
<p>本文件將深入解析 DSPy 的核心原理與架構，探討其如何透過 Signatures、Modules 和 Teleprompters 等抽象層，將 LLM 應用開發從藝術轉變為科學。我們將學習如何使用 Python 程式碼定義 AI 的任務模組，並透過 DSPy 的自動優化機制，實現 LLM 應用程式的自動化、可擴展和高性能開發，從而徹底告別傳統提示工程的困境。</p>
<h2>2. Architecture / Design</h2>
<p>DSPy 的核心設計理念是將 LLM 應用程式視為一個可編譯的系統，其架構圍繞著三個關鍵的抽象層：Signatures、Modules 和 Teleprompters (或稱 Optimizers)。這些抽象層共同構成了一個強大的框架，使得開發者能夠以宣告式的方式構建、優化和部署 LLM 應用 [3]。</p>
<h3>2.1 DSPy 的三大抽象層</h3>
<h4>2.1.1 Signatures (簽名)</h4>
<ul>
<li><strong>定義</strong>：Signature 是 DSPy 中最基礎的抽象，它以宣告式的方式定義了 LLM 任務的<strong>輸入-輸出行為</strong>。它描述了「<strong>做什麼</strong>」，而不是「<strong>怎麼做</strong>」 [4]。</li>
<li><strong>功能</strong>：一個 Signature 就像一個函數簽名，它明確指定了輸入欄位（input fields）和輸出欄位（output fields），以及它們的簡短描述。例如，一個問答任務的 Signature 可以是 <code>question -&gt; answer</code>，其中 <code>question</code> 和 <code>answer</code> 都是帶有描述的字串。</li>
<li><strong>優勢</strong>：透過 Signature，開發者無需關心底層的提示詞具體措辭，只需專注於任務的邏輯定義。DSPy 會根據這個 Signature 自動生成最適合 LLM 的提示詞。</li>
</ul>
<h4>2.1.2 Modules (模組)</h4>
<ul>
<li><strong>定義</strong>：Module 是 DSPy 中用於定義 LLM 應用程式<strong>邏輯結構</strong>的抽象。它將 LLM 應用程式分解為可組合、可重用的組件，類似於 PyTorch 中的 <code>nn.Module</code> [5]。</li>
<li><strong>功能</strong>：一個 Module 可以是一個簡單的 LLM 調用（例如 <code>dspy.Predict</code>），也可以是一個複雜的多步驟推理鏈（例如 <code>dspy.ChainOfThought</code>、<code>dspy.ReAct</code>）。開發者可以將多個 Module 組合起來，構建複雜的 LLM 管道（Pipeline）。</li>
<li><strong>優勢</strong>：Module 使得 LLM 應用程式的開發更加模組化和結構化。每個 Module 都有明確的輸入和輸出，易於測試、調試和重用。當底層 LLM 模型或策略需要更換時，只需替換相應的 Module 即可，而無需修改整個應用程式的邏輯。</li>
</ul>
<h4>2.1.3 Teleprompters / Optimizers (優化器)</h4>
<ul>
<li><strong>定義</strong>：Teleprompter（在 DSPy 中也常稱為 Optimizer）是 DSPy 的核心創新之一，它是一個<strong>自動化演算法</strong>，負責根據給定的數據集和評估指標，自動優化 DSPy 程式中的提示詞和/或 LLM 權重 [6]。</li>
<li><strong>功能</strong>：Teleprompter 不會手動編寫提示詞，而是透過迭代和搜索，找到最能提升 LLM 應用程式性能的提示詞結構、Few-shot 範例、推理步驟等。常見的 Teleprompters 包括 <code>BootstrapFewShot</code>、<code>BayesianSignatureOptimizer</code> 等 [7]。</li>
<li><strong>優勢</strong>：Teleprompter 徹底解決了手動提示詞工程的痛點。它使得 LLM 應用程式能夠自我改進，自動適應不同的數據集和模型，從而實現更高的性能和更強的魯棒性。開發者只需提供少量帶標籤的數據和一個評估指標，Teleprompter 就能自動完成提示詞的優化工作。</li>
</ul>
<h3>2.2 DSPy 編譯工作流 (Compilation Workflow)</h3>
<p>DSPy 的開發流程可以概括為一個「編譯」過程，類似於傳統軟體開發中的編譯器將高階語言轉換為機器碼：</p>
<ol>
<li><strong>定義程式 (Define Program)</strong>：開發者使用 Python 程式碼，透過 DSPy 的 Signatures 和 Modules 來定義 LLM 應用程式的邏輯。這是一個宣告式的過程，專注於「做什麼」和「如何組合」。</li>
<li><strong>定義指標 (Define Metric)</strong>：開發者需要為應用程式定義一個或多個評估指標（Metric），用於衡量其性能。例如，對於問答系統，可以是答案的精確度、語意相似度或召回率。</li>
<li><strong>編譯 (Compile)</strong>：這是 DSPy 最獨特的一步。開發者選擇一個 Teleprompter（Optimizer），並提供一個小的訓練數據集和定義好的指標。Teleprompter 會在這個數據集上運行，透過迭代和搜索，自動生成或調整 DSPy 程式中所有 Modules 的內部提示詞、Few-shot 範例和推理步驟。最終，它會輸出一個「編譯後」的 DSPy 程式物件 [8]。</li>
<li><strong>執行 (Execute)</strong>：一旦程式被「編譯」完成，開發者就可以使用這個優化後的 DSPy 程式物件來處理新的輸入。此時，所有的提示詞和推理邏輯都已經被 Teleprompter 自動優化，應用程式將以最佳性能運行。</li>
</ol>
<h2>3. Prerequisites</h2>
<p>要開始使用 DSPy 進行 LLM 應用開發，您需要具備以下環境和知識：</p>
<ul>
<li><strong>Python 環境</strong>：建議使用 Python 3.9 或更高版本。</li>
<li><strong>基礎 Python 程式設計知識</strong>：熟悉 Python 的類別、函數和物件導向程式設計。</li>
<li><strong>LLM 基礎知識</strong>：理解大型語言模型的基本工作原理、提示詞工程的基本概念。</li>
<li><strong>數據集概念</strong>：理解訓練數據集、評估指標在機器學習中的作用。</li>
<li><strong>安裝 DSPy</strong>：透過 <code>pip install dspy-ai</code> 安裝 DSPy 框架。</li>
<li><strong>LLM API 金鑰</strong>：需要配置您選擇的 LLM 服務提供商的 API 金鑰，例如 OpenAI、Anthropic、Google Gemini 等。</li>
</ul>
<h2>4. Implementation / Code Example</h2>
<p>本節將提供一個使用 DSPy 實現簡單問答系統的範例，展示如何定義 Signature、使用 Module，並透過 Teleprompter 進行自動優化。</p>
<h3>4.1 專案初始化與安裝</h3>
<pre><code class="language-bash">mkdir dspy-qa-example
cd dspy-qa-example
pip install dspy-ai openai # 假設使用 OpenAI 作為 LLM
</code></pre>
<h3>4.2 配置 LLM</h3>
<p>創建 <code>.env</code> 檔案來儲存您的 OpenAI API 金鑰：</p>
<pre><code class="language-dotenv">OPENAI_API_KEY=your_openai_api_key_here
</code></pre>
<p>然後在程式碼中配置 DSPy 使用該 LLM：</p>
<pre><code class="language-python">import dspy
import os
from dotenv import load_dotenv

load_dotenv()

# 配置 LLM
llm = dspy.OpenAI(model=\&quot;gpt-3.5-turbo\&quot;, api_key=os.getenv(\&quot;OPENAI_API_KEY\&quot;))
dspy.settings.configure(lm=llm)
</code></pre>
<h3>4.3 定義 Signature</h3>
<p>我們定義一個簡單的問答 Signature，它接收一個 <code>question</code> 並返回一個 <code>answer</code>。</p>
<pre><code class="language-python">class BasicQA(dspy.Signature):
    \&quot;\&quot;\&quot;根據問題提供簡潔的答案。\&quot;\&quot;\&quot;
    question = dspy.InputField(desc=\&quot;使用者提出的問題\&quot;)
    answer = dspy.OutputField(desc=\&quot;問題的簡潔答案\&quot;)
</code></pre>
<h3>4.4 定義 Module</h3>
<p>對於這個簡單的問答任務，我們可以直接使用 <code>dspy.Predict</code> Module，它會根據 Signature 自動生成提示詞。</p>
<pre><code class="language-python">class SimpleQAModule(dspy.Module):
    def __init__(self):
        super().__init__()
        self.predict = dspy.Predict(BasicQA) # 使用 BasicQA Signature

    def forward(self, question):
        return self.predict(question=question)
</code></pre>
<h3>4.5 準備數據集與評估指標</h3>
<p>DSPy 需要少量帶標籤的數據來進行優化。這裡我們創建一個小的範例數據集。評估指標則用於衡量答案的正確性。</p>
<pre><code class="language-python"># 範例數據集 (通常來自真實世界的數據)
# 每個範例包含輸入 (question) 和期望的輸出 (answer)
qa_dataset = [
    dspy.Example(question=\&quot;地球是圓的嗎？\&quot;, answer=\&quot;是的，地球是圓的。\&quot;),
    dspy.Example(question=\&quot;水的化學式是什麼？\&quot;, answer=\&quot;水的化學式是 H2O。\&quot;),
    dspy.Example(question=\&quot;誰發明了燈泡？\&quot;, answer=\&quot;托馬斯·愛迪生。\&quot;),
]

# 定義一個簡單的評估函數 (實際應用中會更複雜)
# 這裡我們只檢查答案是否包含關鍵詞
def simple_evaluate(pred_answer, gold_answer):
    return gold_answer.lower() in pred_answer.lower()

class MyEvaluator(dspy.evaluate.Evaluator):
    def __init__(self):
        super().__init__(metric=self.metric)

    def metric(self, example, pred, trace=None):
        # 這裡的 example 是 qa_dataset 中的一個 dspy.Example
        # pred 是 LLM 的預測結果
        # trace 是 DSPy 內部執行的軌跡 (用於調試)
        return simple_evaluate(pred.answer, example.answer)

my_evaluator = MyEvaluator()
</code></pre>
<h3>4.6 使用 Teleprompter 進行優化</h3>
<p>我們使用 <code>BootstrapFewShot</code> Teleprompter 來自動生成 Few-shot 範例，以優化 <code>SimpleQAModule</code>。</p>
<pre><code class="language-python">from dspy.teleprompter import BootstrapFewShot

# 創建一個 Teleprompter
teleprompter = BootstrapFewShot(metric=my_evaluator.metric)

# 編譯/優化我們的 QA 模組
# 會在 qa_dataset 上運行，並嘗試找到最佳的 Few-shot 範例
optimized_qa_module = teleprompter.compile(SimpleQAModule(), trainset=qa_dataset)

# 顯示優化後的提示詞 (會包含自動生成的 Few-shot 範例)
print(&quot;\n--- 優化後的提示詞 (部分) ---&quot;)
print(optimized_qa_module.predict.extended_predictors[0].lm.history[-1].prompt)
</code></pre>
<h3>4.7 執行優化後的模組</h3>
<pre><code class="language-python"># 使用優化後的模組進行推理
print(&quot;\n--- 使用優化後的模組進行推理 ---&quot;)
response = optimized_qa_module(question=\&quot;太陽系的中心是什麼？\&quot;)
print(f\&quot;問題: 太陽系的中心是什麼？\n答案: {response.answer}\&quot;)

response = optimized_qa_module(question=\&quot;Python 的創始人是誰？\&quot;)
print(f\&quot;問題: Python 的創始人是誰？\n答案: {response.answer}\&quot;)
</code></pre>
<h3>4.8 完整程式碼 (<code>main.py</code>)</h3>
<pre><code class="language-python">import dspy
import os
import re
from dotenv import load_dotenv
from dspy.teleprompter import BootstrapFewShot

# 載入環境變數
load_dotenv()

# 1. 配置 LLM
llm = dspy.OpenAI(model=\&quot;gpt-3.5-turbo\&quot;, api_key=os.getenv(\&quot;OPENAI_API_KEY\&quot;))
dspy.settings.configure(lm=llm)

# 2. 定義 Signature
class BasicQA(dspy.Signature):
    \&quot;\&quot;\&quot;根據問題提供簡潔的答案。\&quot;\&quot;\&quot;
    question = dspy.InputField(desc=\&quot;使用者提出的問題\&quot;)
    answer = dspy.OutputField(desc=\&quot;問題的簡潔答案\&quot;)

# 3. 定義 Module
class SimpleQAModule(dspy.Module):
    def __init__(self):
        super().__init__()
        self.predict = dspy.Predict(BasicQA)

    def forward(self, question):
        return self.predict(question=question)

# 4. 準備數據集與評估指標
qa_dataset = [
    dspy.Example(question=\&quot;地球是圓的嗎？\&quot;, answer=\&quot;是的，地球是圓的。\&quot;),
    dspy.Example(question=\&quot;水的化學式是什麼？\&quot;, answer=\&quot;水的化學式是 H2O。\&quot;),
    dspy.Example(question=\&quot;誰發明了燈泡？\&quot;, answer=\&quot;托馬斯·愛迪生。\&quot;),
    dspy.Example(question=\&quot;光速是多少？\&quot;, answer=\&quot;約每秒 299,792,458 公尺。\&quot;),
]

def simple_evaluate(pred_answer, gold_answer):
    return gold_answer.lower() in pred_answer.lower()

class MyEvaluator(dspy.evaluate.Evaluator):
    def __init__(self):
        super().__init__(metric=self.metric)

    def metric(self, example, pred, trace=None):
        return simple_evaluate(pred.answer, example.answer)

my_evaluator = MyEvaluator()

# 5. 使用 Teleprompter 進行優化
teleprompter = BootstrapFewShot(metric=my_evaluator.metric)
optimized_qa_module = teleprompter.compile(SimpleQAModule(), trainset=qa_dataset)

# 顯示優化後的提示詞 (會包含自動生成的 Few-shot 範例)
print(&quot;\n--- 優化後的提示詞 (部分) ---&quot;)
# 注意：這裡的索引可能需要根據實際運行情況調整，以獲取正確的提示詞
# 這是獲取 dspy.Predict 內部提示詞的一種方式
if optimized_qa_module.predict.extended_predictors:
    print(optimized_qa_module.predict.extended_predictors[0].lm.history[-1].prompt)
else:
    print(&quot;無法獲取優化後的提示詞，可能需要更多訓練數據或不同的 Teleprompter。&quot;)

# 6. 執行優化後的模組
print(&quot;\n--- 使用優化後的模組進行推理 ---&quot;)
response = optimized_qa_module(question=\&quot;太陽系的中心是什麼？\&quot;)
print(f\&quot;問題: 太陽系的中心是什麼？\n答案: {response.answer}\&quot;)

response = optimized_qa_module(question=\&quot;Python 的創始人是誰？\&quot;)
print(f\&quot;問題: Python 的創始人是誰？\n答案: {response.answer}\&quot;)

response = optimized_qa_module(question=\&quot;萬有引力定律是誰提出的？\&quot;)
print(f\&quot;問題: 萬有引力定律是誰提出的？\n答案: {response.answer}\&quot;)
</code></pre>
<h2>5. Parameters / API Reference</h2>
<p>DSPy 的 API 參考主要體現在其核心類別和函數上，這些構成了開發者構建和優化 LLM 應用程式的介面。</p>
<h3>5.1 <code>dspy.Signature</code> 相關參數</h3>
<p>| 參數/屬性     | 類型         | 描述                                                                 |
| :------------ | :----------- | :------------------------------------------------------------------- |
| <code>InputField</code>  | <code>dspy.Field</code> | 定義 Signature 的輸入欄位，可指定 <code>desc</code> (描述) 和 <code>prefix</code> (前綴)。 |
| <code>OutputField</code> | <code>dspy.Field</code> | 定義 Signature 的輸出欄位，可指定 <code>desc</code> (描述) 和 <code>prefix</code> (前綴)。 |</p>
<h3>5.2 <code>dspy.Module</code> 相關類別</h3>
<p>| 類別                  | 描述                                                           |
| :-------------------- | :------------------------------------------------------------- |
| <code>dspy.Predict</code>        | 最基本的 Module，根據 Signature 進行單次 LLM 預測。            |
| <code>dspy.ChainOfThought</code> | 實現思維鏈（Chain-of-Thought）推理，將複雜任務分解為多個步驟。 |
| <code>dspy.ReAct</code>          | 實現 ReAct（Reasoning and Acting）模式，結合推理和工具使用。   |
| <code>dspy.Retrieve</code>       | 實現檢索（Retrieval）功能，從外部知識庫獲取相關資訊。          |
| <code>dspy.Program</code>        | 用於組合多個 Module 形成一個完整的 LLM 應用程式。              |</p>
<h3>5.3 <code>dspy.Teleprompter</code> (Optimizer) 相關類別</h3>
<p>| 類別                         | 描述                                                      |
| :--------------------------- | :-------------------------------------------------------- |
| <code>BootstrapFewShot</code>           | 透過引導（Bootstrapping）生成 Few-shot 範例來優化提示詞。 |
| <code>BayesianSignatureOptimizer</code> | 使用貝葉斯優化來搜索最佳的 Signature 結構和提示詞。       |
| <code>SignatureOptimizer</code>         | 基礎的 Signature 優化器，用於調整提示詞的措辭。           |
| <code>Ensemble</code>                   | 組合多個優化後的程式，以提高魯棒性。                      |</p>
<h3>5.4 <code>dspy.settings.configure</code> 參數</h3>
<p>| 參數名稱 | 類型      | 描述                                                |
| :------- | :-------- | :-------------------------------------------------- |
| <code>lm</code>     | <code>dspy.LM</code> | 配置要使用的語言模型實例（例如 <code>dspy.OpenAI</code>）。    |
| <code>rm</code>     | <code>dspy.RM</code> | 配置要使用的檢索模型實例（例如 <code>dspy.ColBERTv2</code>）。 |</p>
<h2>6. Notes &amp; Best Practices</h2>
<ol>
<li><strong>從 Signature 開始</strong>：始終從清晰地定義任務的 Signature 開始。這是 DSPy 程式的基石，它明確了輸入和輸出，讓 DSPy 能夠自動生成提示詞 [4]。</li>
<li><strong>模組化設計</strong>：將複雜的 LLM 應用程式分解為小的、可管理的 Module。這不僅提高了程式碼的可讀性和可維護性，也使得每個 Module 都可以獨立優化 [5]。</li>
<li><strong>數據集的重要性</strong>：儘管 DSPy 減少了手動提示詞工程，但它仍然需要少量的高品質數據集來進行優化。這些數據集用於訓練 Teleprompter，使其能夠學習如何生成最佳的提示詞和 Few-shot 範例 [8]。</li>
<li><strong>選擇合適的 Teleprompter</strong>：不同的 Teleprompter 適用於不同的優化目標和場景。例如，<code>BootstrapFewShot</code> 適合於生成 Few-shot 範例，而 <code>BayesianSignatureOptimizer</code> 則更適合於搜索最佳的 Signature 結構 [7]。</li>
<li><strong>迭代優化</strong>：DSPy 的優化過程是迭代的。您可能需要嘗試不同的 Teleprompter、調整數據集或評估指標，以找到最佳的程式性能。</li>
<li><strong>評估指標的精確性</strong>：優化器的效果直接取決於評估指標的精確性。一個好的評估指標能夠準確地反映應用程式的性能，從而引導優化器找到更好的解決方案。</li>
<li><strong>可解釋性與調試</strong>：DSPy 提供了 <code>dspy.settings.trace()</code> 等工具，可以追蹤 LLM 的內部調用和提示詞生成過程，這對於理解和調試優化後的程式非常有幫助。</li>
</ol>
<h2>7. 為什麼選擇這種方式？</h2>
<p>從傳統的手寫 Prompt Engineering 轉向 DSPy 框架，代表著 LLM 應用開發範式的重大演進，其優勢在於：</p>
<ol>
<li><strong>告別手寫 Prompt 的脆弱性</strong>：傳統的手寫 Prompt 極易受到 LLM 模型更新、任務細節變化或不同模型之間差異的影響，導致測試失敗和高昂的維護成本。DSPy 透過將提示詞的生成自動化，使得應用程式對這些變化更具彈性，從根本上解決了 Prompt 的脆弱性問題 [1]。</li>
<li><strong>實現 LLM 應用程式的自動化優化</strong>：DSPy 的 Teleprompters 能夠根據數據集和評估指標，自動搜索和迭代出最佳的提示詞、Few-shot 範例和推理步驟。這意味著開發者不再需要憑藉直覺或經驗來猜測最佳提示詞，而是讓 AI 自己學習如何更好地完成任務，從而實現 LLM 應用程式的自我改進和性能最大化 [2]。</li>
<li><strong>提升開發效率與可維護性</strong>：DSPy 引入了 Signatures 和 Modules 等抽象層，使得 LLM 應用程式的開發更加模組化、結構化和宣告式。開發者可以像編寫傳統軟體一樣，定義清晰的任務邏輯和組件，這極大地提升了程式碼的可讀性、可重用性和可維護性 [3]。</li>
<li><strong>增強 LLM 應用程式的魯棒性與可擴展性</strong>：透過自動優化，DSPy 程式在面對不同的輸入數據或底層 LLM 模型時，能夠表現出更強的魯棒性。同時，模組化的設計也使得應用程式更容易擴展，以應對更複雜的任務和不斷變化的需求 [8]。</li>
<li><strong>從「提示詞工程師」轉向「AI 系統架構師」</strong>：DSPy 改變了 AI 開發者的角色。開發者不再是提示詞的「工匠」，而是專注於設計數據流、定義評估指標和構建模組化邏輯的「AI 系統架構師」。這使得開發者能夠從低層次的提示詞細節中解放出來，專注於更高層次的系統設計和業務價值 [9]。</li>
</ol>
<hr/>
<p><strong>參考資料</strong></p>
<ul>
<li>[1] Statsig. (2025, October 31). <em>DSPy vs prompt engineering: Systematic vs manual tuning</em>. Retrieved from https://www.statsig.com/perspectives/dspy-vs-prompt-tuning</li>
<li>[2] DSPy. (n.d.). <em>Programming LLMs with DSPy</em>. Retrieved from https://dspy.ai/learn/programming/</li>
<li>[3] Medium. (2024, June 3). <em>An Exploratory Tour of DSPy: A Framework for Programing LLMs</em>. Retrieved from https://medium.com/the-modern-scientist/an-exploratory-tour-of-dspy-a-framework-for-programing-language-models-not-prompting-711bc4a56376</li>
<li>[4] DSPy. (n.d.). <em>Signatures</em>. Retrieved from https://dspy.ai/learn/programming/signatures/</li>
<li>[5] IBM. (n.d.). <em>What is DSPy?</em>. Retrieved from https://www.ibm.com/think/topics/dspy</li>
<li>[6] DSPy. (n.d.). <em>Optimizers</em>. Retrieved from https://dspy.ai/learn/optimization/optimizers/</li>
<li>[7] The Data Quarry. (2025, October 13). <em>Learning DSPy (3): Working with optimizers</em>. Retrieved from https://thedataquarry.com/blog/learning-dspy-3-working-with-optimizers</li>
<li>[8] Statsig. (2025, October 31). <em>DSPy fundamentals: Programmatic LLM optimization</em>. Retrieved from https://www.statsig.com/perspectives/dspy-fundamentals-llm-optimization</li>
<li>[9] blog.devwithawais.com. (2025, November 27). <em>6 Surprising Truths About DSPy That Make Manual Prompting Obsolete</em>. Retrieved from https://blog.devwithawais.com/6-surprising-truths-about-dspy-that-make-manual-prompting-obsolete-a13c85a5c458</li>
</ul></div></div></div></div></div></article><!--$--><!--/$--><!--$--><!--/$--></main><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><noscript>You need to enable JavaScript to run this app.</noscript><div class="position-fixed" style="z-index:1050;bottom:20px;right:20px;transform:translate(0px, 0px);touch-action:none;cursor:default;display:flex;flex-direction:column;align-items:flex-end;transition:transform 0.3s ease"><div class="position-relative"><button class="btn btn-primary rounded-circle d-flex align-items-center justify-content-center shadow" style="width:56px;height:56px;cursor:grab" aria-label="切換聊天視窗"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width:24px;height:24px;pointer-events:none"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"></path></svg></button><span class="position-absolute bg-danger rounded-circle" style="width:12px;height:12px;top:0;right:0;border:2px solid white"></span></div></div><script src="https://qwer820921.github.io/_next/static/chunks/webpack-97372da6a069f2e6.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[69243,[\"8482\",\"static/chunks/8482-5637f60b9e0ae224.js\",\"7177\",\"static/chunks/app/layout-898a3761c5f29253.js\"],\"\"]\n3:I[6476,[\"8482\",\"static/chunks/8482-5637f60b9e0ae224.js\",\"7177\",\"static/chunks/app/layout-898a3761c5f29253.js\"],\"default\"]\n4:I[87555,[],\"\"]\n5:I[31295,[],\"\"]\n6:I[39543,[\"8482\",\"static/chunks/8482-5637f60b9e0ae224.js\",\"7177\",\"static/chunks/app/layout-898a3761c5f29253.js\"],\"default\"]\n8:I[59665,[],\"MetadataBoundary\"]\na:I[59665,[],\"OutletBoundary\"]\nd:I[74911,[],\"AsyncMetadataOutlet\"]\nf:I[59665,[],\"ViewportBoundary\"]\n11:I[26614,[],\"\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/be607b33620c6e00.css\",\"style\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/739e5c607d9731d5.css\",\"style\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/4bb1c53d4d41ca49.css\",\"style\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/0105f7c97f16220d.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"LzA9qndiC87434dpeGU-O\",\"p\":\"https://qwer820921.github.io\",\"c\":[\"\",\"blog\",\"transition-from-prompt-engineering-to-dspy\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"transition-from-prompt-engineering-to-dspy\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/be607b33620c6e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/739e5c607d9731d5.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/4bb1c53d4d41ca49.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-Hant\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.ico\"}],[\"$\",\"link\",null,{\"rel\":\"apple-touch-icon\",\"href\":\"/logo192.png\"}],[\"$\",\"link\",null,{\"rel\":\"manifest\",\"href\":\"/manifest.json\"}],[\"$\",\"link\",null,{\"rel\":\"preload\",\"href\":\"/logo192.png\",\"as\":\"image\"}],[\"$\",\"$L2\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-CCKVESHCQ1\"}],[\"$\",\"$L2\",null,{\"id\":\"google-analytics\",\"children\":\"\\n            window.dataLayer = window.dataLayer || [];\\n            function gtag(){dataLayer.push(arguments);}\\n            gtag('js', new Date());\\n            gtag('config', 'G-CCKVESHCQ1');\\n          \"}],[\"$\",\"$L2\",null,{\"async\":true,\"src\":\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2709303513603814\",\"crossOrigin\":\"anonymous\"}]]}],[\"$\",\"body\",null,{\"children\":[[\"$\",\"$L3\",null,{\"children\":[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"$L6\",null,{}]]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"transition-from-prompt-engineering-to-dspy\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/0105f7c97f16220d.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"WUe8owpQyb7n0qGH6pUtg\",{\"children\":[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],null]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"12:\"$Sreact.suspense\"\n13:I[74911,[],\"AsyncMetadata\"]\n9:[\"$\",\"$12\",null,{\"fallback\":null,\"children\":[\"$\",\"$L13\",null,{\"promise\":\"$@14\"}]}]\n"])</script><script>self.__next_f.push([1,"15:I[57113,[\"6874\",\"static/chunks/6874-cfa829be98f8140c.js\",\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-c93c0e23c9658930.js\"],\"default\"]\nc:null\n7:[\"$\",\"article\",null,{\"className\":\"container py-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"row justify-content-center\",\"children\":[\"$\",\"div\",null,{\"className\":\"col-12 col-lg-8\",\"children\":[[\"$\",\"$L15\",null,{}],[\"$\",\"div\",null,{\"className\":\"card shadow-sm border-0\",\"children\":[\"$\",\"div\",null,{\"className\":\"card-body p-4 p-md-5\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-5 pb-4 border-bottom\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"fw-bold mb-3 display-5\",\"children\":\"【提示工程終結者】從 Prompt Engineering 轉向 DSPy (Declarative Self-improving Python)\"}],[\"$\",\"div\",null,{\"className\":\"text-muted d-flex align-items-center gap-2\",\"children\":[[\"$\",\"i\",null,{\"className\":\"bi bi-calendar3\"}],\"2026-02-12\"]}]]}],[\"$\",\"div\",null,{\"className\":\"blogContent_blogContent__VY_R4\",\"children\":\"$L16\"}]]}]}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"17:Taf3,"])</script><script>self.__next_f.push([1,"import dspy\nimport os\nimport re\nfrom dotenv import load_dotenv\nfrom dspy.teleprompter import BootstrapFewShot\n\n# 載入環境變數\nload_dotenv()\n\n# 1. 配置 LLM\nllm = dspy.OpenAI(model=\\\"gpt-3.5-turbo\\\", api_key=os.getenv(\\\"OPENAI_API_KEY\\\"))\ndspy.settings.configure(lm=llm)\n\n# 2. 定義 Signature\nclass BasicQA(dspy.Signature):\n    \\\"\\\"\\\"根據問題提供簡潔的答案。\\\"\\\"\\\"\n    question = dspy.InputField(desc=\\\"使用者提出的問題\\\")\n    answer = dspy.OutputField(desc=\\\"問題的簡潔答案\\\")\n\n# 3. 定義 Module\nclass SimpleQAModule(dspy.Module):\n    def __init__(self):\n        super().__init__()\n        self.predict = dspy.Predict(BasicQA)\n\n    def forward(self, question):\n        return self.predict(question=question)\n\n# 4. 準備數據集與評估指標\nqa_dataset = [\n    dspy.Example(question=\\\"地球是圓的嗎？\\\", answer=\\\"是的，地球是圓的。\\\"),\n    dspy.Example(question=\\\"水的化學式是什麼？\\\", answer=\\\"水的化學式是 H2O。\\\"),\n    dspy.Example(question=\\\"誰發明了燈泡？\\\", answer=\\\"托馬斯·愛迪生。\\\"),\n    dspy.Example(question=\\\"光速是多少？\\\", answer=\\\"約每秒 299,792,458 公尺。\\\"),\n]\n\ndef simple_evaluate(pred_answer, gold_answer):\n    return gold_answer.lower() in pred_answer.lower()\n\nclass MyEvaluator(dspy.evaluate.Evaluator):\n    def __init__(self):\n        super().__init__(metric=self.metric)\n\n    def metric(self, example, pred, trace=None):\n        return simple_evaluate(pred.answer, example.answer)\n\nmy_evaluator = MyEvaluator()\n\n# 5. 使用 Teleprompter 進行優化\nteleprompter = BootstrapFewShot(metric=my_evaluator.metric)\noptimized_qa_module = teleprompter.compile(SimpleQAModule(), trainset=qa_dataset)\n\n# 顯示優化後的提示詞 (會包含自動生成的 Few-shot 範例)\nprint(\"\\n--- 優化後的提示詞 (部分) ---\")\n# 注意：這裡的索引可能需要根據實際運行情況調整，以獲取正確的提示詞\n# 這是獲取 dspy.Predict 內部提示詞的一種方式\nif optimized_qa_module.predict.extended_predictors:\n    print(optimized_qa_module.predict.extended_predictors[0].lm.history[-1].prompt)\nelse:\n    print(\"無法獲取優化後的提示詞，可能需要更多訓練數據或不同的 Teleprompter。\")\n\n# 6. 執行優化後的模組\nprint(\"\\n--- 使用優化後的模組進行推理 ---\")\nresponse = optimized_qa_module(question=\\\"太陽系的中心是什麼？\\\")\nprint(f\\\"問題: 太陽系的中心是什麼？\\n答案: {response.answer}\\\")\n\nresponse = optimized_qa_module(question=\\\"Python 的創始人是誰？\\\")\nprint(f\\\"問題: Python 的創始人是誰？\\n答案: {response.answer}\\\")\n\nresponse = optimized_qa_module(question=\\\"萬有引力定律是誰提出的？\\\")\nprint(f\\\"問題: 萬有引力定律是誰提出的？\\n答案: {response.answer}\\\")\n"])</script><script>self.__next_f.push([1,"16:[[\"$\",\"h1\",null,{\"children\":\"【提示工程終結者】從 Prompt Engineering 轉向 DSPy (Declarative Self-improving Python)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"作者：\"}],\" Manus AI\\n\",[\"$\",\"strong\",null,{\"children\":\"日期：\"}],\" 2026年2月11日\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"1. Overview\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"在大型語言模型（LLM）應用開發的早期階段，「提示工程（Prompt Engineering）」是核心技能。開發者花費大量時間精心設計、迭代和微調提示詞（Prompt），以引導 LLM 產生期望的輸出。然而，這種手動的提示詞工程方法存在顯著的局限性：它\",[\"$\",\"strong\",null,{\"children\":\"脆弱\"}],\"、\",[\"$\",\"strong\",null,{\"children\":\"難以維護\"}],\"、\",[\"$\",\"strong\",null,{\"children\":\"難以擴展\"}],\"，且\",[\"$\",\"strong\",null,{\"children\":\"缺乏系統性\"}],\" [1]。當底層 LLM 模型更新、任務需求變化或需要遷移到不同模型時，手寫的提示詞往往會失效，導致巨大的維護成本。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"進入 2026 年，業界對 LLM 應用開發的觀點已發生根本性轉變：「手寫 Prompt 是脆弱的」。由史丹佛大學提出的 \",[\"$\",\"strong\",null,{\"children\":\"DSPy (Declarative Self-improving Python)\"}],\" 框架，正是為了解決這一痛點而生。DSPy 允許開發者以宣告式（Declarative）的方式定義 LLM 應用程式的邏輯和任務模組，而不是直接編寫提示詞。它將提示詞的生成與優化交給了自動化的「編譯器（Compiler）」和「優化器（Optimizer）」，這些工具能夠透過少量的數據集，自動迭代出比人類手寫更強大、更穩健的提示詞結構 [2]。\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"本文件將深入解析 DSPy 的核心原理與架構，探討其如何透過 Signatures、Modules 和 Teleprompters 等抽象層，將 LLM 應用開發從藝術轉變為科學。我們將學習如何使用 Python 程式碼定義 AI 的任務模組，並透過 DSPy 的自動優化機制，實現 LLM 應用程式的自動化、可擴展和高性能開發，從而徹底告別傳統提示工程的困境。\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"2. Architecture / Design\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"DSPy 的核心設計理念是將 LLM 應用程式視為一個可編譯的系統，其架構圍繞著三個關鍵的抽象層：Signatures、Modules 和 Teleprompters (或稱 Optimizers)。這些抽象層共同構成了一個強大的框架，使得開發者能夠以宣告式的方式構建、優化和部署 LLM 應用 [3]。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"2.1 DSPy 的三大抽象層\"}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"2.1.1 Signatures (簽名)\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"定義\"}],\"：Signature 是 DSPy 中最基礎的抽象，它以宣告式的方式定義了 LLM 任務的\",[\"$\",\"strong\",null,{\"children\":\"輸入-輸出行為\"}],\"。它描述了「\",[\"$\",\"strong\",null,{\"children\":\"做什麼\"}],\"」，而不是「\",[\"$\",\"strong\",null,{\"children\":\"怎麼做\"}],\"」 [4]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"功能\"}],\"：一個 Signature 就像一個函數簽名，它明確指定了輸入欄位（input fields）和輸出欄位（output fields），以及它們的簡短描述。例如，一個問答任務的 Signature 可以是 \",[\"$\",\"code\",null,{\"children\":\"question -\u003e answer\"}],\"，其中 \",[\"$\",\"code\",null,{\"children\":\"question\"}],\" 和 \",[\"$\",\"code\",null,{\"children\":\"answer\"}],\" 都是帶有描述的字串。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"優勢\"}],\"：透過 Signature，開發者無需關心底層的提示詞具體措辭，只需專注於任務的邏輯定義。DSPy 會根據這個 Signature 自動生成最適合 LLM 的提示詞。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"2.1.2 Modules (模組)\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"定義\"}],\"：Module 是 DSPy 中用於定義 LLM 應用程式\",[\"$\",\"strong\",null,{\"children\":\"邏輯結構\"}],\"的抽象。它將 LLM 應用程式分解為可組合、可重用的組件，類似於 PyTorch 中的 \",[\"$\",\"code\",null,{\"children\":\"nn.Module\"}],\" [5]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"功能\"}],\"：一個 Module 可以是一個簡單的 LLM 調用（例如 \",[\"$\",\"code\",null,{\"children\":\"dspy.Predict\"}],\"），也可以是一個複雜的多步驟推理鏈（例如 \",[\"$\",\"code\",null,{\"children\":\"dspy.ChainOfThought\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"dspy.ReAct\"}],\"）。開發者可以將多個 Module 組合起來，構建複雜的 LLM 管道（Pipeline）。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"優勢\"}],\"：Module 使得 LLM 應用程式的開發更加模組化和結構化。每個 Module 都有明確的輸入和輸出，易於測試、調試和重用。當底層 LLM 模型或策略需要更換時，只需替換相應的 Module 即可，而無需修改整個應用程式的邏輯。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"2.1.3 Teleprompters / Optimizers (優化器)\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"定義\"}],\"：Teleprompter（在 DSPy 中也常稱為 Optimizer）是 DSPy 的核心創新之一，它是一個\",[\"$\",\"strong\",null,{\"children\":\"自動化演算法\"}],\"，負責根據給定的數據集和評估指標，自動優化 DSPy 程式中的提示詞和/或 LLM 權重 [6]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"功能\"}],\"：Teleprompter 不會手動編寫提示詞，而是透過迭代和搜索，找到最能提升 LLM 應用程式性能的提示詞結構、Few-shot 範例、推理步驟等。常見的 Teleprompters 包括 \",[\"$\",\"code\",null,{\"children\":\"BootstrapFewShot\"}],\"、\",[\"$\",\"code\",null,{\"children\":\"BayesianSignatureOptimizer\"}],\" 等 [7]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"優勢\"}],\"：Teleprompter 徹底解決了手動提示詞工程的痛點。它使得 LLM 應用程式能夠自我改進，自動適應不同的數據集和模型，從而實現更高的性能和更強的魯棒性。開發者只需提供少量帶標籤的數據和一個評估指標，Teleprompter 就能自動完成提示詞的優化工作。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"2.2 DSPy 編譯工作流 (Compilation Workflow)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"DSPy 的開發流程可以概括為一個「編譯」過程，類似於傳統軟體開發中的編譯器將高階語言轉換為機器碼：\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"定義程式 (Define Program)\"}],\"：開發者使用 Python 程式碼，透過 DSPy 的 Signatures 和 Modules 來定義 LLM 應用程式的邏輯。這是一個宣告式的過程，專注於「做什麼」和「如何組合」。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"定義指標 (Define Metric)\"}],\"：開發者需要為應用程式定義一個或多個評估指標（Metric），用於衡量其性能。例如，對於問答系統，可以是答案的精確度、語意相似度或召回率。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"編譯 (Compile)\"}],\"：這是 DSPy 最獨特的一步。開發者選擇一個 Teleprompter（Optimizer），並提供一個小的訓練數據集和定義好的指標。Teleprompter 會在這個數據集上運行，透過迭代和搜索，自動生成或調整 DSPy 程式中所有 Modules 的內部提示詞、Few-shot 範例和推理步驟。最終，它會輸出一個「編譯後」的 DSPy 程式物件 [8]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"執行 (Execute)\"}],\"：一旦程式被「編譯」完成，開發者就可以使用這個優化後的 DSPy 程式物件來處理新的輸入。此時，所有的提示詞和推理邏輯都已經被 Teleprompter 自動優化，應用程式將以最佳性能運行。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"3. Prerequisites\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"要開始使用 DSPy 進行 LLM 應用開發，您需要具備以下環境和知識：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Python 環境\"}],\"：建議使用 Python 3.9 或更高版本。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"基礎 Python 程式設計知識\"}],\"：熟悉 Python 的類別、函數和物件導向程式設計。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"LLM 基礎知識\"}],\"：理解大型語言模型的基本工作原理、提示詞工程的基本概念。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"數據集概念\"}],\"：理解訓練數據集、評估指標在機器學習中的作用。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"安裝 DSPy\"}],\"：透過 \",[\"$\",\"code\",null,{\"children\":\"pip install dspy-ai\"}],\" 安裝 DSPy 框架。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"LLM API 金鑰\"}],\"：需要配置您選擇的 LLM 服務提供商的 API 金鑰，例如 OpenAI、Anthropic、Google Gemini 等。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"4. Implementation / Code Example\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"本節將提供一個使用 DSPy 實現簡單問答系統的範例，展示如何定義 Signature、使用 Module，並透過 Teleprompter 進行自動優化。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.1 專案初始化與安裝\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-bash\",\"children\":\"mkdir dspy-qa-example\\ncd dspy-qa-example\\npip install dspy-ai openai # 假設使用 OpenAI 作為 LLM\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.2 配置 LLM\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"創建 \",[\"$\",\"code\",null,{\"children\":\".env\"}],\" 檔案來儲存您的 OpenAI API 金鑰：\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-dotenv\",\"children\":\"OPENAI_API_KEY=your_openai_api_key_here\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"然後在程式碼中配置 DSPy 使用該 LLM：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-python\",\"children\":\"import dspy\\nimport os\\nfrom dotenv import load_dotenv\\n\\nload_dotenv()\\n\\n# 配置 LLM\\nllm = dspy.OpenAI(model=\\\\\\\"gpt-3.5-turbo\\\\\\\", api_key=os.getenv(\\\\\\\"OPENAI_API_KEY\\\\\\\"))\\ndspy.settings.configure(lm=llm)\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.3 定義 Signature\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"我們定義一個簡單的問答 Signature，它接收一個 \",[\"$\",\"code\",null,{\"children\":\"question\"}],\" 並返回一個 \",[\"$\",\"code\",null,{\"children\":\"answer\"}],\"。\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-python\",\"children\":\"class BasicQA(dspy.Signature):\\n    \\\\\\\"\\\\\\\"\\\\\\\"根據問題提供簡潔的答案。\\\\\\\"\\\\\\\"\\\\\\\"\\n    question = dspy.InputField(desc=\\\\\\\"使用者提出的問題\\\\\\\")\\n    answer = dspy.OutputField(desc=\\\\\\\"問題的簡潔答案\\\\\\\")\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.4 定義 Module\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"對於這個簡單的問答任務，我們可以直接使用 \",[\"$\",\"code\",null,{\"children\":\"dspy.Predict\"}],\" Module，它會根據 Signature 自動生成提示詞。\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-python\",\"children\":\"class SimpleQAModule(dspy.Module):\\n    def __init__(self):\\n        super().__init__()\\n        self.predict = dspy.Predict(BasicQA) # 使用 BasicQA Signature\\n\\n    def forward(self, question):\\n        return self.predict(question=question)\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.5 準備數據集與評估指標\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"DSPy 需要少量帶標籤的數據來進行優化。這裡我們創建一個小的範例數據集。評估指標則用於衡量答案的正確性。\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-python\",\"children\":\"# 範例數據集 (通常來自真實世界的數據)\\n# 每個範例包含輸入 (question) 和期望的輸出 (answer)\\nqa_dataset = [\\n    dspy.Example(question=\\\\\\\"地球是圓的嗎？\\\\\\\", answer=\\\\\\\"是的，地球是圓的。\\\\\\\"),\\n    dspy.Example(question=\\\\\\\"水的化學式是什麼？\\\\\\\", answer=\\\\\\\"水的化學式是 H2O。\\\\\\\"),\\n    dspy.Example(question=\\\\\\\"誰發明了燈泡？\\\\\\\", answer=\\\\\\\"托馬斯·愛迪生。\\\\\\\"),\\n]\\n\\n# 定義一個簡單的評估函數 (實際應用中會更複雜)\\n# 這裡我們只檢查答案是否包含關鍵詞\\ndef simple_evaluate(pred_answer, gold_answer):\\n    return gold_answer.lower() in pred_answer.lower()\\n\\nclass MyEvaluator(dspy.evaluate.Evaluator):\\n    def __init__(self):\\n        super().__init__(metric=self.metric)\\n\\n    def metric(self, example, pred, trace=None):\\n        # 這裡的 example 是 qa_dataset 中的一個 dspy.Example\\n        # pred 是 LLM 的預測結果\\n        # trace 是 DSPy 內部執行的軌跡 (用於調試)\\n        return simple_evaluate(pred.answer, example.answer)\\n\\nmy_evaluator = MyEvaluator()\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.6 使用 Teleprompter 進行優化\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"我們使用 \",[\"$\",\"code\",null,{\"children\":\"BootstrapFewShot\"}],\" Teleprompter 來自動生成 Few-shot 範例，以優化 \",[\"$\",\"code\",null,{\"children\":\"SimpleQAModule\"}],\"。\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-python\",\"children\":\"from dspy.teleprompter import BootstrapFewShot\\n\\n# 創建一個 Teleprompter\\nteleprompter = BootstrapFewShot(metric=my_evaluator.metric)\\n\\n# 編譯/優化我們的 QA 模組\\n# 會在 qa_dataset 上運行，並嘗試找到最佳的 Few-shot 範例\\noptimized_qa_module = teleprompter.compile(SimpleQAModule(), trainset=qa_dataset)\\n\\n# 顯示優化後的提示詞 (會包含自動生成的 Few-shot 範例)\\nprint(\\\"\\\\n--- 優化後的提示詞 (部分) ---\\\")\\nprint(optimized_qa_module.predict.extended_predictors[0].lm.history[-1].prompt)\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.7 執行優化後的模組\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-python\",\"children\":\"# 使用優化後的模組進行推理\\nprint(\\\"\\\\n--- 使用優化後的模組進行推理 ---\\\")\\nresponse = optimized_qa_module(question=\\\\\\\"太陽系的中心是什麼？\\\\\\\")\\nprint(f\\\\\\\"問題: 太陽系的中心是什麼？\\\\n答案: {response.answer}\\\\\\\")\\n\\nresponse = optimized_qa_module(question=\\\\\\\"Python 的創始人是誰？\\\\\\\")\\nprint(f\\\\\\\"問題: Python 的創始人是誰？\\\\n答案: {response.answer}\\\\\\\")\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"4.8 完整程式碼 (\",[\"$\",\"code\",null,{\"children\":\"main.py\"}],\")\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-python\",\"children\":\"$17\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"5. Parameters / API Reference\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"DSPy 的 API 參考主要體現在其核心類別和函數上，這些構成了開發者構建和優化 LLM 應用程式的介面。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"5.1 \",[\"$\",\"code\",null,{\"children\":\"dspy.Signature\"}],\" 相關參數\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"| 參數/屬性     | 類型         | 描述                                                                 |\\n| :------------ | :----------- | :------------------------------------------------------------------- |\\n| \",[\"$\",\"code\",null,{\"children\":\"InputField\"}],\"  | \",[\"$\",\"code\",null,{\"children\":\"dspy.Field\"}],\" | 定義 Signature 的輸入欄位，可指定 \",[\"$\",\"code\",null,{\"children\":\"desc\"}],\" (描述) 和 \",[\"$\",\"code\",null,{\"children\":\"prefix\"}],\" (前綴)。 |\\n| \",[\"$\",\"code\",null,{\"children\":\"OutputField\"}],\" | \",[\"$\",\"code\",null,{\"children\":\"dspy.Field\"}],\" | 定義 Signature 的輸出欄位，可指定 \",[\"$\",\"code\",null,{\"children\":\"desc\"}],\" (描述) 和 \",[\"$\",\"code\",null,{\"children\":\"prefix\"}],\" (前綴)。 |\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"5.2 \",[\"$\",\"code\",null,{\"children\":\"dspy.Module\"}],\" 相關類別\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"| 類別                  | 描述                                                           |\\n| :-------------------- | :------------------------------------------------------------- |\\n| \",[\"$\",\"code\",null,{\"children\":\"dspy.Predict\"}],\"        | 最基本的 Module，根據 Signature 進行單次 LLM 預測。            |\\n| \",[\"$\",\"code\",null,{\"children\":\"dspy.ChainOfThought\"}],\" | 實現思維鏈（Chain-of-Thought）推理，將複雜任務分解為多個步驟。 |\\n| \",[\"$\",\"code\",null,{\"children\":\"dspy.ReAct\"}],\"          | 實現 ReAct（Reasoning and Acting）模式，結合推理和工具使用。   |\\n| \",[\"$\",\"code\",null,{\"children\":\"dspy.Retrieve\"}],\"       | 實現檢索（Retrieval）功能，從外部知識庫獲取相關資訊。          |\\n| \",[\"$\",\"code\",null,{\"children\":\"dspy.Program\"}],\"        | 用於組合多個 Module 形成一個完整的 LLM 應用程式。              |\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"5.3 \",[\"$\",\"code\",null,{\"children\":\"dspy.Teleprompter\"}],\" (Optimizer) 相關類別\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"| 類別                         | 描述                                                      |\\n| :--------------------------- | :-------------------------------------------------------- |\\n| \",[\"$\",\"code\",null,{\"children\":\"BootstrapFewShot\"}],\"           | 透過引導（Bootstrapping）生成 Few-shot 範例來優化提示詞。 |\\n| \",[\"$\",\"code\",null,{\"children\":\"BayesianSignatureOptimizer\"}],\" | 使用貝葉斯優化來搜索最佳的 Signature 結構和提示詞。       |\\n| \",[\"$\",\"code\",null,{\"children\":\"SignatureOptimizer\"}],\"         | 基礎的 Signature 優化器，用於調整提示詞的措辭。           |\\n| \",[\"$\",\"code\",null,{\"children\":\"Ensemble\"}],\"                   | 組合多個優化後的程式，以提高魯棒性。                      |\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"5.4 \",[\"$\",\"code\",null,{\"children\":\"dspy.settings.configure\"}],\" 參數\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"| 參數名稱 | 類型      | 描述                                                |\\n| :------- | :-------- | :-------------------------------------------------- |\\n| \",[\"$\",\"code\",null,{\"children\":\"lm\"}],\"     | \",[\"$\",\"code\",null,{\"children\":\"dspy.LM\"}],\" | 配置要使用的語言模型實例（例如 \",[\"$\",\"code\",null,{\"children\":\"dspy.OpenAI\"}],\"）。    |\\n| \",[\"$\",\"code\",null,{\"children\":\"rm\"}],\"     | \",[\"$\",\"code\",null,{\"children\":\"dspy.RM\"}],\" | 配置要使用的檢索模型實例（例如 \",[\"$\",\"code\",null,{\"children\":\"dspy.ColBERTv2\"}],\"）。 |\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"6. Notes \u0026 Best Practices\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"從 Signature 開始\"}],\"：始終從清晰地定義任務的 Signature 開始。這是 DSPy 程式的基石，它明確了輸入和輸出，讓 DSPy 能夠自動生成提示詞 [4]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"模組化設計\"}],\"：將複雜的 LLM 應用程式分解為小的、可管理的 Module。這不僅提高了程式碼的可讀性和可維護性，也使得每個 Module 都可以獨立優化 [5]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"數據集的重要性\"}],\"：儘管 DSPy 減少了手動提示詞工程，但它仍然需要少量的高品質數據集來進行優化。這些數據集用於訓練 Teleprompter，使其能夠學習如何生成最佳的提示詞和 Few-shot 範例 [8]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"選擇合適的 Teleprompter\"}],\"：不同的 Teleprompter 適用於不同的優化目標和場景。例如，\",[\"$\",\"code\",null,{\"children\":\"BootstrapFewShot\"}],\" 適合於生成 Few-shot 範例，而 \",[\"$\",\"code\",null,{\"children\":\"BayesianSignatureOptimizer\"}],\" 則更適合於搜索最佳的 Signature 結構 [7]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"迭代優化\"}],\"：DSPy 的優化過程是迭代的。您可能需要嘗試不同的 Teleprompter、調整數據集或評估指標，以找到最佳的程式性能。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"評估指標的精確性\"}],\"：優化器的效果直接取決於評估指標的精確性。一個好的評估指標能夠準確地反映應用程式的性能，從而引導優化器找到更好的解決方案。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"可解釋性與調試\"}],\"：DSPy 提供了 \",[\"$\",\"code\",null,{\"children\":\"dspy.settings.trace()\"}],\" 等工具，可以追蹤 LLM 的內部調用和提示詞生成過程，這對於理解和調試優化後的程式非常有幫助。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"7. 為什麼選擇這種方式？\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"從傳統的手寫 Prompt Engineering 轉向 DSPy 框架，代表著 LLM 應用開發範式的重大演進，其優勢在於：\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"告別手寫 Prompt 的脆弱性\"}],\"：傳統的手寫 Prompt 極易受到 LLM 模型更新、任務細節變化或不同模型之間差異的影響，導致測試失敗和高昂的維護成本。DSPy 透過將提示詞的生成自動化，使得應用程式對這些變化更具彈性，從根本上解決了 Prompt 的脆弱性問題 [1]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"實現 LLM 應用程式的自動化優化\"}],\"：DSPy 的 Teleprompters 能夠根據數據集和評估指標，自動搜索和迭代出最佳的提示詞、Few-shot 範例和推理步驟。這意味著開發者不再需要憑藉直覺或經驗來猜測最佳提示詞，而是讓 AI 自己學習如何更好地完成任務，從而實現 LLM 應用程式的自我改進和性能最大化 [2]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"提升開發效率與可維護性\"}],\"：DSPy 引入了 Signatures 和 Modules 等抽象層，使得 LLM 應用程式的開發更加模組化、結構化和宣告式。開發者可以像編寫傳統軟體一樣，定義清晰的任務邏輯和組件，這極大地提升了程式碼的可讀性、可重用性和可維護性 [3]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"增強 LLM 應用程式的魯棒性與可擴展性\"}],\"：透過自動優化，DSPy 程式在面對不同的輸入數據或底層 LLM 模型時，能夠表現出更強的魯棒性。同時，模組化的設計也使得應用程式更容易擴展，以應對更複雜的任務和不斷變化的需求 [8]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"從「提示詞工程師」轉向「AI 系統架構師」\"}],\"：DSPy 改變了 AI 開發者的角色。開發者不再是提示詞的「工匠」，而是專注於設計數據流、定義評估指標和構建模組化邏輯的「AI 系統架構師」。這使得開發者能夠從低層次的提示詞細節中解放出來，專注於更高層次的系統設計和業務價值 [9]。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"參考資料\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[1] Statsig. (2025, October 31). \",[\"$\",\"em\",null,{\"children\":\"DSPy vs prompt engineering: Systematic vs manual tuning\"}],\". Retrieved from https://www.statsig.com/perspectives/dspy-vs-prompt-tuning\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[2] DSPy. (n.d.). \",[\"$\",\"em\",null,{\"children\":\"Programming LLMs with DSPy\"}],\". Retrieved from https://dspy.ai/learn/programming/\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[3] Medium. (2024, June 3). \",[\"$\",\"em\",null,{\"children\":\"An Exploratory Tour of DSPy: A Framework for Programing LLMs\"}],\". Retrieved from https://medium.com/the-modern-scientist/an-exploratory-tour-of-dspy-a-framework-for-programing-language-models-not-prompting-711bc4a56376\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[4] DSPy. (n.d.). \",[\"$\",\"em\",null,{\"children\":\"Signatures\"}],\". Retrieved from https://dspy.ai/learn/programming/signatures/\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[5] IBM. (n.d.). \",[\"$\",\"em\",null,{\"children\":\"What is DSPy?\"}],\". Retrieved from https://www.ibm.com/think/topics/dspy\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[6] DSPy. (n.d.). \",[\"$\",\"em\",null,{\"children\":\"Optimizers\"}],\". Retrieved from https://dspy.ai/learn/optimization/optimizers/\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[7] The Data Quarry. (2025, October 13). \",[\"$\",\"em\",null,{\"children\":\"Learning DSPy (3): Working with optimizers\"}],\". Retrieved from https://thedataquarry.com/blog/learning-dspy-3-working-with-optimizers\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[8] Statsig. (2025, October 31). \",[\"$\",\"em\",null,{\"children\":\"DSPy fundamentals: Programmatic LLM optimization\"}],\". Retrieved from https://www.statsig.com/perspectives/dspy-fundamentals-llm-optimization\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[9] blog.devwithawais.com. (2025, November 27). \",[\"$\",\"em\",null,{\"children\":\"6 Surprising Truths About DSPy That Make Manual Prompting Obsolete\"}],\". Retrieved from https://blog.devwithawais.com/6-surprising-truths-about-dspy-that-make-manual-prompting-obsolete-a13c85a5c458\"]}],\"\\n\"]}]]\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"14:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"【提示工程終結者】從 Prompt Engineering 轉向 DSPy (Declarative Self-improving Python) | 子yee 萬事屋 | 子yee\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"深入解析 DSPy 框架如何透過宣告式程式設計與自動優化機制，徹底改變 LLM 應用開發範式，告別手寫 Prompt 的脆弱性。\"}],[\"$\",\"meta\",\"2\",{\"name\":\"keywords\",\"content\":\"子yee 萬事屋, 台股查詢, 自選股, 技術小工具, 股票資訊平台, 技術顧問, 自動化工具\"}],[\"$\",\"meta\",\"3\",{\"name\":\"google-site-verification\",\"content\":\"adHIcDQiasHY4YzPlrpmSSPKl7Oj1WxrPJ_4GV4PQcM\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"【提示工程終結者】從 Prompt Engineering 轉向 DSPy (Declarative Self-improving Python)\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"深入解析 DSPy 框架如何透過宣告式程式設計與自動優化機制，徹底改變 LLM 應用開發範式，告別手寫 Prompt 的脆弱性。\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:image\",\"content\":\"https://qwer820921.github.io/images/img15.jpg\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image:height\",\"content\":\"630\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:image:alt\",\"content\":\"【提示工程終結者】從 Prompt Engineering 轉向 DSPy (Declarative Self-improving Python)\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"11\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:title\",\"content\":\"【提示工程終結者】從 Prompt Engineering 轉向 DSPy (Declarative Self-improving Python)\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:description\",\"content\":\"深入解析 DSPy 框架如何透過宣告式程式設計與自動優化機制，徹底改變 LLM 應用開發範式，告別手寫 Prompt 的脆弱性。\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:image\",\"content\":\"https://qwer820921.github.io/images/img15.jpg\"}],[\"$\",\"link\",\"15\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"e:{\"metadata\":\"$14:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>