<!DOCTYPE html><html lang="zh-Hant"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/f71b761575b48bd6.css" data-precedence="next"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/e57a9f01512809bb.css" data-precedence="next"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/4bb1c53d4d41ca49.css" data-precedence="next"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/45df6ee84bc085cd.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="https://qwer820921.github.io/_next/static/chunks/webpack-c887150ca99864ad.js"/><script src="https://qwer820921.github.io/_next/static/chunks/4bd1b696-e100a0b1879d5e6b.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/1684-9b53760636e10952.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/main-app-c0d2570cf703bee2.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/6283-1586b7e20e5a28d4.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/app/layout-984d35e9d146542e.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/app/blog/%5Bslug%5D/page-bad5b7683d758711.js" async=""></script><link rel="preload" href="https://qwer820921.github.io/_next/static/chunks/2990.e74a1c7b49aeb05a.js" as="script" fetchPriority="low"/><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-CCKVESHCQ1" as="script"/><link rel="preload" href="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2709303513603814" as="script" crossorigin=""/><link rel="icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/logo192.png"/><link rel="manifest" href="/manifest.json"/><link rel="preload" href="/logo192.png" as="image"/><title>【系統部署】前端應用程式的 Docker 容器化與本地部署指南 | 子yee 萬事屋 | 子yee</title><meta name="description" content="一份詳盡的前端應用程式 Docker 容器化指南，涵蓋多階段構建、Nginx 優化配置及本地部署工作流，確保開發與生產環境一致性。"/><meta name="author" content="子yee"/><meta name="keywords" content="子yee 萬事屋, 台股查詢, 自選股, 技術小工具, 股票資訊平台, 技術顧問, 自動化工具"/><meta name="google-site-verification" content="adHIcDQiasHY4YzPlrpmSSPKl7Oj1WxrPJ_4GV4PQcM"/><meta property="og:title" content="【系統部署】前端應用程式的 Docker 容器化與本地部署指南"/><meta property="og:description" content="一份詳盡的前端應用程式 Docker 容器化指南，涵蓋多階段構建、Nginx 優化配置及本地部署工作流，確保開發與生產環境一致性。"/><meta property="og:image" content="https://qwer820921.github.io/images/img15.jpg"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:alt" content="【系統部署】前端應用程式的 Docker 容器化與本地部署指南"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="【系統部署】前端應用程式的 Docker 容器化與本地部署指南"/><meta name="twitter:description" content="一份詳盡的前端應用程式 Docker 容器化指南，涵蓋多階段構建、Nginx 優化配置及本地部署工作流，確保開發與生產環境一致性。"/><meta name="twitter:image" content="https://qwer820921.github.io/images/img15.jpg"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="64x64"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="https://qwer820921.github.io/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><main class="container-fluid p-0"><article class="container py-5"><div class="row justify-content-center"><div class="col-12 col-lg-8"><div class="card blogPost_articleCard__LIiRr"><div class="card-body blogPost_cardBody__5xHPD"><header class="blogPost_articleHeader__dQ5vG"><div id="static-back-btn" style="display:inline-flex;margin-bottom:1rem;cursor:pointer;position:relative;z-index:1"><div class="btn d-inline-flex align-items-center gap-2 shadow rounded-pill px-4 py-2 text-decoration-none" role="button" style="pointer-events:auto;background-color:#fff;backdrop-filter:none;border:1px solid rgba(0,0,0,0.08);color:#495057;font-weight:500;transition:all 0.2s ease;cursor:pointer"><span>回到文章列表</span></div></div><h1 class="blogPost_articleTitle__BCXQE">【系統部署】前端應用程式的 Docker 容器化與本地部署指南</h1><div class="blogPost_articleMeta__1R_wB"><div class="blogPost_metaItem__xpKuj"><i class="bi bi-person-fill blogPost_metaIcon__h8wBb"></i><span class="blogPost_metaLabel__y0uVD">作者:</span>子yee</div><div class="blogPost_metaItem__xpKuj"><i class="bi bi-calendar3 blogPost_metaIcon__h8wBb"></i><span class="blogPost_metaLabel__y0uVD">日期:</span>2026-02-07</div></div></header><div class="blogContent_blogContent__VY_R4"><h2>1. Overview</h2>
<p>在現代前端開發中，將應用程式容器化已成為標準實踐，尤其是在微服務架構和 CI/CD 流水線中。Docker 提供了一種輕量級、可移植且自給自足的環境，確保應用程式在任何地方都能以相同的方式運行，從而解決了長期困擾開發者的「在我機器上可以跑」的問題。本指南將專注於如何為前端應用程式（如基於 React, Angular, Vue 的單頁應用程式 SPA）進行高效的 Docker 容器化，並透過 Nginx 進行生產環境的最佳化服務，最終實現便捷的本地開發與部署工作流。</p>
<p>透過本指南，您將學習到如何利用多階段構建（Multi-stage Build）技術來創建最小化且安全的 Docker 映像檔，如何配置 Nginx 作為高性能的靜態檔案伺服器，以及如何使用 Docker Compose 簡化本地開發環境的設置和應用程式的啟動。這將有助於提升開發效率、確保環境一致性，並為未來的生產部署奠定堅實基礎。</p>
<h2>2. Architecture / Design</h2>
<p>前端應用程式的 Docker 容器化部署架構，旨在將前端應用程式的構建（Build）與運行（Run）環境分離，並透過 Nginx 提供高效的靜態檔案服務。這種設計模式確保了最終映像檔的輕量化、安全性與高性能。</p>
<h3>2.1 專案結構 (Project Structure)</h3>
<p>一個典型的容器化前端專案將包含以下核心檔案和目錄結構：</p>
<pre><code>. # 專案根目錄
├── my-frontend-app/ # 前端應用程式目錄
│   ├── src/ # 原始碼
│   ├── public/ # 靜態資源
│   ├── package.json # NPM 依賴管理
│   ├── Dockerfile # Docker 構建檔案
│   └── nginx.conf # Nginx 伺服器配置檔案
└── docker-compose.yml # Docker Compose 配置檔案 (用於本地開發/多服務協調)
</code></pre>
<h3>2.2 Dockerfile 設計 (Dockerfile Design) - 多階段構建 (Multi-stage Build)</h3>
<p>多階段構建是 Dockerfile 的一項關鍵特性，它允許在一個 Dockerfile 中定義多個 <code>FROM</code> 指令，每個 <code>FROM</code> 指令都代表一個構建階段。這樣做的好處是，最終的映像檔只包含運行應用程式所需的最小化組件，而不會包含構建時所需的龐大工具和依賴。這顯著減少了映像檔的大小，提升了安全性和部署速度。</p>
<h4>2.2.1 第一階段：構建階段 (Build Stage)</h4>
<p>此階段的目標是安裝所有前端專案的開發依賴，並執行構建命令（例如 <code>npm run build</code> 或 <code>yarn build</code>），生成生產環境所需的靜態檔案。我們通常會選擇一個包含 Node.js 環境的基礎映像檔。</p>
<pre><code class="language-dockerfile"># Stage 1: Build the frontend application
FROM node:lts-alpine as builder

# Set the working directory inside the container
WORKDIR /app

# Copy package.json and package-lock.json (or yarn.lock) to leverage Docker cache
COPY package*.json ./

# Install dependencies
RUN npm install --silent

# Copy the rest of the application code
COPY . .

# Build the application for production
# Replace &#x27;npm run build&#x27; with your specific build command (e.g., &#x27;ng build --configuration=production&#x27;)
RUN npm run build

# The build output will typically be in a &#x27;dist&#x27; or &#x27;build&#x27; folder
# For example, for React it&#x27;s &#x27;build&#x27;, for Angular it&#x27;s &#x27;dist/&lt;project-name&gt;&#x27;
# For this example, we assume the output is in &#x27;dist&#x27;
</code></pre>
<h4>2.2.2 第二階段：運行階段 (Runtime Stage)</h4>
<p>此階段的目標是只包含運行前端應用程式所需的最小化環境，即一個輕量級的靜態檔案伺服器 Nginx。它將從第一階段複製構建好的靜態檔案，並配置 Nginx 來服務這些檔案。</p>
<pre><code class="language-dockerfile"># Stage 2: Serve the application with Nginx
FROM nginx:alpine

# Copy the custom Nginx configuration file
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Copy the built frontend application from the &#x27;builder&#x27; stage
# Adjust &#x27;/app/dist&#x27; to your actual build output directory from Stage 1
COPY --from=builder /app/dist /usr/share/nginx/html

# Expose port 80 for Nginx
EXPOSE 80

# Command to run Nginx when the container starts
CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
</code></pre>
<h3>2.3 Nginx 配置 (Nginx Configuration) - <code>nginx.conf</code></h3>
<p>Nginx 作為一個高性能的 Web 伺服器，非常適合用來服務前端應用的靜態檔案。對於單頁應用程式（SPA），Nginx 的配置需要特別處理路由回退（Fallback Routing），以確保所有未匹配的路由都能指向 <code>index.html</code>。</p>
<pre><code class="language-nginx"># nginx.conf
server {
    listen 80;
    server_name localhost;

    # Set the root directory for serving static files
    # This should match the directory where your built frontend files are copied
    root /usr/share/nginx/html;
    index index.html index.htm;

    # Try to serve files directly, if not found, fallback to index.html
    # This is crucial for Single Page Applications (SPAs) to handle client-side routing
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Optional: Configure caching for static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|woff|woff2|ttf|svg|eot)$ {
        expires 30d;
        add_header Cache-Control &quot;public, no-transform&quot;;
    }

    # Optional: Enable Gzip compression for better performance
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_min_length 256;
    gzip_vary on;

    # Optional: Add security headers
    add_header X-Frame-Options &quot;DENY&quot;;
    add_header X-Content-Type-Options &quot;nosniff&quot;;
    add_header X-XSS-Protection &quot;1; mode=block&quot;;
    add_header Referrer-Policy &quot;no-referrer-when-downgrade&quot;;
    # Content-Security-Policy can be complex, configure carefully
    # add_header Content-Security-Policy &quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27;; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;; img-src &#x27;self&#x27; data:; font-src &#x27;self&#x27;;&quot;;
}
</code></pre>
<h3>2.4 Docker Compose 配置 (Docker Compose Configuration) - <code>docker-compose.yml</code></h3>
<p>Docker Compose 是一個用於定義和運行多容器 Docker 應用程式的工具。透過一個 YAML 檔案，您可以配置應用程式的服務、網路和儲存。對於本地部署，它極大地簡化了多個服務（例如前端、後端 API、資料庫）的協調與啟動。</p>
<pre><code class="language-yaml"># docker-compose.yml
version: &quot;3.8&quot;

services:
  frontend:
    build:
      context: ./my-frontend-app # 指向 Dockerfile 所在的目錄
      dockerfile: Dockerfile
    ports:
      - &quot;80:80&quot; # 將主機的 80 埠映射到容器的 80 埠
    # volumes: # 僅在開發環境下考慮使用，生產環境不建議
    #   - ./my-frontend-app:/usr/share/nginx/html # 將本地程式碼掛載到容器，實現熱重載
    # environment: # 如果前端應用程式需要運行時環境變數
    #   - API_BASE_URL=http://localhost:3000
    restart: always # 容器退出後自動重啟
</code></pre>
<h2>3. Prerequisites</h2>
<p>在開始容器化前端應用程式之前，請確保您的開發環境已安裝以下工具：</p>
<ul>
<li><strong>Docker Desktop</strong> 或 <strong>Docker Engine</strong>: 這是運行 Docker 容器的基礎。您可以從 <a href="https://www.docker.com/get-started">Docker 官方網站</a> 下載並安裝。</li>
<li><strong>Node.js &amp; npm/yarn</strong>: 用於前端應用程式的開發和構建。雖然 Dockerfile 會處理容器內的 Node.js 環境，但在本地開發時仍需要。</li>
<li><strong>一個前端應用程式</strong>: 任何基於 React, Angular, Vue 或其他框架的單頁應用程式。</li>
</ul>
<h2>4. Implementation / Code Example</h2>
<p>以下將提供一個完整的實作範例，假設您有一個名為 <code>my-frontend-app</code> 的前端專案。</p>
<h3>4.1 專案設置</h3>
<p>首先，確保您的專案結構如 <code>2.1 專案結構</code> 中所示。在 <code>my-frontend-app</code> 目錄下，您應該有您的前端程式碼、<code>package.json</code> 等。然後，創建 <code>Dockerfile</code> 和 <code>nginx.conf</code> 檔案。</p>
<h3>4.2 <code>my-frontend-app/Dockerfile</code></h3>
<p>請參考 <code>2.2 Dockerfile 設計</code> 中的多階段構建範例，將其內容複製到您的 <code>my-frontend-app/Dockerfile</code> 檔案中。請務必根據您的前端框架調整 <code>RUN npm run build</code> 命令和 <code>COPY --from=builder /app/dist</code> 的路徑。</p>
<h3>4.3 <code>my-frontend-app/nginx.conf</code></h3>
<p>請參考 <code>2.3 Nginx 配置</code> 中的範例，將其內容複製到您的 <code>my-frontend-app/nginx.conf</code> 檔案中。此配置已針對 SPA 進行優化，並包含基本的快取和 Gzip 壓縮。</p>
<h3>4.4 <code>docker-compose.yml</code></h3>
<p>在專案的根目錄（與 <code>my-frontend-app</code> 同級）創建 <code>docker-compose.yml</code> 檔案，並複製 <code>2.4 Docker Compose 配置</code> 中的內容。確保 <code>context</code> 指向正確的前端應用程式目錄。</p>
<h3>4.5 本地部署工作流 (Local Deployment Workflow)</h3>
<p>完成上述檔案設置後，您可以按照以下步驟在本地部署您的前端應用程式：</p>
<ol>
<li><strong>打開終端機</strong>：導航到包含 <code>docker-compose.yml</code> 檔案的專案根目錄。</li>
<li><strong>構建並啟動容器</strong>：執行以下命令。<!-- -->
<pre><code class="language-bash">docker-compose up --build -d
</code></pre>
<ul>
<li><code>up</code>: 啟動服務。</li>
<li><code>--build</code>: 強制重新構建映像檔，確保使用最新的 <code>Dockerfile</code> 和程式碼。</li>
<li><code>-d</code>: 在後台運行容器（detached mode）。</li>
</ul>
</li>
<li><strong>驗證服務</strong>：等待 Docker 映像檔構建完成並啟動容器。您可以使用 <code>docker-compose ps</code> 命令查看容器狀態。</li>
<li><strong>訪問應用程式</strong>：打開您的瀏覽器，訪問 <code>http://localhost</code> (如果 <code>docker-compose.yml</code> 中映射的是 80 埠)。</li>
<li><strong>停止與清理</strong>：當您完成開發或測試後，可以執行以下命令停止並移除容器、網路和卷。<!-- -->
<pre><code class="language-bash">docker-compose down
</code></pre>
<!-- -->如果您想移除所有映像檔，可以執行 <code>docker-compose down --rmi all</code>。</li>
</ol>
<h2>5. Parameters / API Reference</h2>
<p>此處主要涉及 Dockerfile 指令、Nginx 配置指令和 Docker Compose 服務配置。</p>
<h3>5.1 Dockerfile 關鍵指令</h3>
<table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>FROM</code></td><td style="text-align:left">指定基礎映像檔。多階段構建中會多次使用。</td></tr><tr><td style="text-align:left"><code>WORKDIR</code></td><td style="text-align:left">設定容器內的工作目錄。</td></tr><tr><td style="text-align:left"><code>COPY</code></td><td style="text-align:left">將主機上的檔案或目錄複製到容器內。<code>--from</code> 參數用於從其他構建階段複製檔案。</td></tr><tr><td style="text-align:left"><code>RUN</code></td><td style="text-align:left">在當前映像檔層中執行命令。常用於安裝依賴、構建應用程式。</td></tr><tr><td style="text-align:left"><code>EXPOSE</code></td><td style="text-align:left">聲明容器在運行時監聽的埠號。這是一個文檔說明，不實際發布埠號。</td></tr><tr><td style="text-align:left"><code>CMD</code></td><td style="text-align:left">提供容器啟動時的預設執行命令。如果 Dockerfile 中有多個 <code>CMD</code>，只有最後一個生效。</td></tr></tbody></table>
<h3>5.2 Nginx <code>nginx.conf</code> 關鍵配置</h3>
<table><thead><tr><th style="text-align:left">配置項</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>listen</code></td><td style="text-align:left">Nginx 監聽的埠號。</td></tr><tr><td style="text-align:left"><code>root</code></td><td style="text-align:left">靜態檔案的根目錄。</td></tr><tr><td style="text-align:left"><code>index</code></td><td style="text-align:left">預設的索引檔案名稱。</td></tr><tr><td style="text-align:left"><code>location /</code></td><td style="text-align:left">處理所有請求的區塊。<code>try_files $uri $uri/ /index.html;</code> 對於 SPA 至關重要，它會嘗試查找檔案，如果找不到則回退到 <code>index.html</code>。</td></tr><tr><td style="text-align:left"><code>gzip on;</code></td><td style="text-align:left">啟用 Gzip 壓縮。</td></tr><tr><td style="text-align:left"><code>expires</code></td><td style="text-align:left">設定 HTTP 響應頭中的 <code>Expires</code> 和 <code>Cache-Control</code>，控制瀏覽器快取。</td></tr><tr><td style="text-align:left"><code>add_header</code></td><td style="text-align:left">添加自定義的 HTTP 響應頭，常用於安全性配置。</td></tr></tbody></table>
<h3>5.3 Docker Compose <code>docker-compose.yml</code> 關鍵配置</h3>
<table><thead><tr><th style="text-align:left">配置項</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>version</code></td><td style="text-align:left">Docker Compose 檔案格式版本。</td></tr><tr><td style="text-align:left"><code>services</code></td><td style="text-align:left">定義應用程式中的各個服務。</td></tr><tr><td style="text-align:left"><code>build</code></td><td style="text-align:left">指定如何構建服務的映像檔。<code>context</code> 指向 <code>Dockerfile</code> 所在目錄，<code>dockerfile</code> 指定 <code>Dockerfile</code> 名稱。</td></tr><tr><td style="text-align:left"><code>ports</code></td><td style="text-align:left">將主機埠號映射到容器埠號。格式為 <code>HOST:CONTAINER</code>。</td></tr><tr><td style="text-align:left"><code>volumes</code></td><td style="text-align:left">將主機路徑或具名卷掛載到容器內。常用於開發時的程式碼同步。</td></tr><tr><td style="text-align:left"><code>environment</code></td><td style="text-align:left">設定容器內的環境變數。</td></tr><tr><td style="text-align:left"><code>restart</code></td><td style="text-align:left">定義容器退出後的重啟策略（例如 <code>always</code>, <code>on-failure</code>）。</td></tr></tbody></table>
<h2>6. Notes &amp; Best Practices</h2>
<ol>
<li><strong>多階段構建的優勢</strong>：始終使用多階段構建。這不僅能大幅縮小最終映像檔的體積，還能減少不必要的依賴和潛在的安全漏洞，因為運行時映像檔只包含必要的組件。</li>
<li><strong>Nginx 配置優化</strong>：<!-- -->
<ul>
<li><strong>SPA 路由回退</strong>：<code>try_files $uri $uri/ /index.html;</code> 是 SPA 部署的關鍵。它確保了無論用戶訪問哪個前端路由，Nginx 都能正確地返回 <code>index.html</code>，讓前端路由器接管。</li>
<li><strong>快取策略</strong>：為靜態資源（JS, CSS, 圖片等）配置合理的 <code>expires</code> 和 <code>Cache-Control</code> 頭，可以顯著提升應用程式的載入速度和用戶體驗。</li>
<li><strong>Gzip 壓縮</strong>：啟用 Gzip 壓縮可以減少傳輸的資料量，尤其對於大型 JS/CSS 檔案效果顯著。</li>
<li><strong>安全性頭</strong>：添加 <code>X-Frame-Options</code>, <code>X-Content-Type-Options</code>, <code>X-XSS-Protection</code> 等 HTTP 安全性頭，可以增強應用程式的安全性。</li>
</ul>
</li>
<li><strong>環境變數管理</strong>：<!-- -->
<ul>
<li>前端應用程式通常需要在運行時獲取不同的環境變數（例如 API 服務的 URL）。避免將敏感資訊硬編碼到程式碼中。</li>
<li>對於 Docker 容器，可以透過 <code>docker-compose.yml</code> 的 <code>environment</code> 區塊或 Dockerfile 中的 <code>ARG</code>/<code>ENV</code> 指令來注入環境變數。在 Nginx 配置中，可以利用 <code>envsubst</code> 在容器啟動時替換 Nginx 配置中的變數。</li>
</ul>
</li>
<li><strong>本地開發與熱重載</strong>：<!-- -->
<ul>
<li>在開發階段，可以考慮在 <code>docker-compose.yml</code> 中使用 <code>volumes</code> 將本地程式碼目錄掛載到容器內，並結合前端開發伺服器的熱重載功能，實現程式碼修改後容器內自動更新。</li>
<li>然而，在生產環境中應避免使用 <code>volumes</code> 掛載程式碼，因為這會增加部署的複雜性並可能引入不一致性。</li>
</ul>
</li>
<li><strong>映像檔標籤 (Image Tagging)</strong>：為您的 Docker 映像檔使用有意義的標籤（例如 <code>v1.0.0</code>, <code>latest</code>, <code>commit-sha</code>），以便於版本管理和回溯。</li>
<li><strong>安全性考量</strong>：<!-- -->
<ul>
<li>使用官方的、受信任的基礎映像檔（例如 <code>node:lts-alpine</code>, <code>nginx:alpine</code>）。</li>
<li>定期更新基礎映像檔，以獲取最新的安全補丁。</li>
<li>避免在最終映像檔中包含不必要的工具和依賴。</li>
</ul>
</li>
</ol>
<h2>7. 為什麼選擇這種方式？</h2>
<p>將前端應用程式進行 Docker 容器化並透過 Nginx 部署，是現代 Web 開發中的一個黃金標準。選擇這種方式，主要基於以下幾個不可或缺的優勢：</p>
<ol>
<li><strong>環境一致性</strong>：Docker 容器提供了一個隔離且標準化的運行環境，確保了應用程式從開發、測試到生產環境的一致性。這極大地減少了因環境差異導致的問題，加速了開發與部署流程。</li>
<li><strong>高效能服務</strong>：Nginx 作為一個輕量級且高效能的 Web 伺服器，非常適合服務前端應用的靜態檔案。其優化的快取機制、Gzip 壓縮以及對 SPA 路由的良好支持，能夠顯著提升應用程式的載入速度和用戶體驗。</li>
<li><strong>資源優化與安全性</strong>：透過多階段構建，最終的 Docker 映像檔只包含運行應用程式所需的最小化組件，不包含構建工具和開發依賴。這不僅使得映像檔體積更小，減少了儲存和傳輸成本，也降低了潛在的安全攻擊面。</li>
<li><strong>簡化部署與擴展</strong>：容器化的應用程式易於部署到任何支援 Docker 的環境，無論是本地開發、測試伺服器還是雲端平台（如 Kubernetes, AWS ECS）。Docker Compose 進一步簡化了本地多服務應用程式的啟動和管理，為未來的水平擴展奠定了基礎。</li>
<li><strong>標準化工作流</strong>：這種模式提供了一個清晰、可重複的部署工作流，有助於團隊成員之間的協作，並能輕鬆整合到 CI/CD 流水線中，實現自動化測試和部署。</li>
</ol>
<hr/>
<p><strong>參考資料</strong></p>
<ul>
<li>[1] OneUptime. (2026, February 2). <em>How to Use Multi-Stage Docker Builds</em>. Retrieved from <a href="https://oneuptime.com/blog/post/2026-02-02-docker-multi-stage-builds/view">https://oneuptime.com/blog/post/2026-02-02-docker-multi-stage-builds/view</a></li>
<li>[2] DEV Community. (2025, October 7). <em>Guide to Containerizing a Modern JavaScript SPA (Vue/Vite/React) with a Multi-Stage Nginx Build</em>. Retrieved from <a href="https://dev.to/it-wibrc/guide-to-containerizing-a-modern-javascript-spa-vuevitereact-with-a-multi-stage-nginx-build-1lma">https://dev.to/it-wibrc/guide-to-containerizing-a-modern-javascript-spa-vuevitereact-with-a-multi-stage-nginx-build-1lma</a></li>
<li>[3] Telerik. (2025, June 4). <em>Deploying Angular Apps with NGINX and Docker</em>. Retrieved from <a href="https://www.telerik.com/blogs/deploying-angular-apps-nginx-docker">https://www.telerik.com/blogs/deploying-angular-apps-nginx-docker</a></li>
<li>[4] Docker. (n.d.). <em>Get Started with Docker</em>. Retrieved from <a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></li>
<li>[5] Heroku Dev Center. (2025, November 5). <em>Local Development with Docker Compose</em>. Retrieved from <a href="https://devcenter.heroku.com/articles/local-development-with-docker-compose">https://devcenter.heroku.com/articles/local-development-with-docker-compose</a></li>
</ul></div></div></div></div></div></article><!--$--><!--/$--><!--$--><!--/$--></main><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><noscript>You need to enable JavaScript to run this app.</noscript><div class="position-fixed" style="z-index:1050;bottom:20px;right:20px;transform:translate(0px, 0px);touch-action:none;cursor:default;display:flex;flex-direction:column;align-items:flex-end;transition:transform 0.3s ease"><div class="position-relative"><button class="btn rounded-circle d-flex align-items-center justify-content-center shadow-lg" style="width:60px;height:60px;cursor:grab;background:linear-gradient(135deg, #0d6efd, #0a58ca);border:2px solid rgba(255,255,255,0.2);transition:transform 0.2s ease" aria-label="切換聊天視窗"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="white" style="width:28px;height:28px;pointer-events:none"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"></path></svg></button><span class="position-absolute bg-danger rounded-circle" style="width:12px;height:12px;top:0;right:0;border:2px solid white"></span></div></div><script src="https://qwer820921.github.io/_next/static/chunks/webpack-c887150ca99864ad.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[69243,[\"6283\",\"static/chunks/6283-1586b7e20e5a28d4.js\",\"7177\",\"static/chunks/app/layout-984d35e9d146542e.js\"],\"\"]\n3:I[6476,[\"6283\",\"static/chunks/6283-1586b7e20e5a28d4.js\",\"7177\",\"static/chunks/app/layout-984d35e9d146542e.js\"],\"default\"]\n4:I[87555,[],\"\"]\n5:I[31295,[],\"\"]\n6:I[39543,[\"6283\",\"static/chunks/6283-1586b7e20e5a28d4.js\",\"7177\",\"static/chunks/app/layout-984d35e9d146542e.js\"],\"default\"]\n8:I[59665,[],\"MetadataBoundary\"]\na:I[59665,[],\"OutletBoundary\"]\nd:I[74911,[],\"AsyncMetadataOutlet\"]\nf:I[59665,[],\"ViewportBoundary\"]\n11:I[26614,[],\"\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/f71b761575b48bd6.css\",\"style\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/e57a9f01512809bb.css\",\"style\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/4bb1c53d4d41ca49.css\",\"style\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/45df6ee84bc085cd.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"kcO7iRNzlwXVMzOFctocS\",\"p\":\"https://qwer820921.github.io\",\"c\":[\"\",\"blog\",\"frontend-docker-deployment-guide\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"frontend-docker-deployment-guide\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/f71b761575b48bd6.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/e57a9f01512809bb.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/4bb1c53d4d41ca49.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-Hant\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.ico\"}],[\"$\",\"link\",null,{\"rel\":\"apple-touch-icon\",\"href\":\"/logo192.png\"}],[\"$\",\"link\",null,{\"rel\":\"manifest\",\"href\":\"/manifest.json\"}],[\"$\",\"link\",null,{\"rel\":\"preload\",\"href\":\"/logo192.png\",\"as\":\"image\"}],[\"$\",\"$L2\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-CCKVESHCQ1\"}],[\"$\",\"$L2\",null,{\"id\":\"google-analytics\",\"children\":\"\\n            window.dataLayer = window.dataLayer || [];\\n            function gtag(){dataLayer.push(arguments);}\\n            gtag('js', new Date());\\n            gtag('config', 'G-CCKVESHCQ1');\\n          \"}],[\"$\",\"$L2\",null,{\"async\":true,\"src\":\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2709303513603814\",\"crossOrigin\":\"anonymous\"}]]}],[\"$\",\"body\",null,{\"children\":[[\"$\",\"$L3\",null,{\"children\":[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"$L6\",null,{}]]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"frontend-docker-deployment-guide\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/45df6ee84bc085cd.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"G3IQ8iqy2ltRYTxr7EUVR\",{\"children\":[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],null]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"12:\"$Sreact.suspense\"\n13:I[74911,[],\"AsyncMetadata\"]\n9:[\"$\",\"$12\",null,{\"fallback\":null,\"children\":[\"$\",\"$L13\",null,{\"promise\":\"$@14\"}]}]\n"])</script><script>self.__next_f.push([1,"15:I[57113,[\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-bad5b7683d758711.js\"],\"default\"]\nc:null\n7:[\"$\",\"article\",null,{\"className\":\"container py-5\",\"children\":[[\"$\",\"div\",null,{\"className\":\"row justify-content-center\",\"children\":[\"$\",\"div\",null,{\"className\":\"col-12 col-lg-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"card blogPost_articleCard__LIiRr\",\"children\":[\"$\",\"div\",null,{\"className\":\"card-body blogPost_cardBody__5xHPD\",\"children\":[[\"$\",\"header\",null,{\"className\":\"blogPost_articleHeader__dQ5vG\",\"children\":[[\"$\",\"$L15\",null,{\"mode\":\"static\",\"id\":\"static-back-btn\"}],[\"$\",\"h1\",null,{\"className\":\"blogPost_articleTitle__BCXQE\",\"children\":\"【系統部署】前端應用程式的 Docker 容器化與本地部署指南\"}],[\"$\",\"div\",null,{\"className\":\"blogPost_articleMeta__1R_wB\",\"children\":[[\"$\",\"div\",null,{\"className\":\"blogPost_metaItem__xpKuj\",\"children\":[[\"$\",\"i\",null,{\"className\":\"bi bi-person-fill blogPost_metaIcon__h8wBb\"}],[\"$\",\"span\",null,{\"className\":\"blogPost_metaLabel__y0uVD\",\"children\":\"作者:\"}],\"子yee\"]}],[\"$\",\"div\",null,{\"className\":\"blogPost_metaItem__xpKuj\",\"children\":[[\"$\",\"i\",null,{\"className\":\"bi bi-calendar3 blogPost_metaIcon__h8wBb\"}],[\"$\",\"span\",null,{\"className\":\"blogPost_metaLabel__y0uVD\",\"children\":\"日期:\"}],\"2026-02-07\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"blogContent_blogContent__VY_R4\",\"children\":\"$L16\"}]]}]}]}]}],[\"$\",\"$L15\",null,{\"mode\":\"floating\",\"targetId\":\"static-back-btn\"}]]}]\n"])</script><script>self.__next_f.push([1,"17:T608,# nginx.conf\nserver {\n    listen 80;\n    server_name localhost;\n\n    # Set the root directory for serving static files\n    # This should match the directory where your built frontend files are copied\n    root /usr/share/nginx/html;\n    index index.html index.htm;\n\n    # Try to serve files directly, if not found, fallback to index.html\n    # This is crucial for Single Page Applications (SPAs) to handle client-side routing\n    location / {\n        try_files $uri $uri/ /index.html;\n    }\n\n    # Optional: Configure caching for static assets\n    location ~* \\.(js|css|png|jpg|jpeg|gif|ico|woff|woff2|ttf|svg|eot)$ {\n        expires 30d;\n        add_header Cache-Control \"public, no-transform\";\n    }\n\n    # Optional: Enable Gzip compression for better performance\n    gzip on;\n    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n    gzip_proxied any;\n    gzip_comp_level 6;\n    gzip_buffers 16 8k;\n    gzip_http_version 1.1;\n    gzip_min_length 256;\n    gzip_vary on;\n\n    # Optional: Add security headers\n    add_header X-Frame-Options \"DENY\";\n    add_header X-Content-Type-Options \"nosniff\";\n    add_header X-XSS-Protection \"1; mode=block\";\n    add_header Referrer-Policy \"no-referrer-when-downgrade\";\n    # Content-Security-Policy can be complex, configure carefully\n    # add_header Content-Security-Policy \"default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self';\";\n}\n"])</script><script>self.__next_f.push([1,"16:[[\"$\",\"h2\",null,{\"children\":\"1. Overview\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"在現代前端開發中，將應用程式容器化已成為標準實踐，尤其是在微服務架構和 CI/CD 流水線中。Docker 提供了一種輕量級、可移植且自給自足的環境，確保應用程式在任何地方都能以相同的方式運行，從而解決了長期困擾開發者的「在我機器上可以跑」的問題。本指南將專注於如何為前端應用程式（如基於 React, Angular, Vue 的單頁應用程式 SPA）進行高效的 Docker 容器化，並透過 Nginx 進行生產環境的最佳化服務，最終實現便捷的本地開發與部署工作流。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"透過本指南，您將學習到如何利用多階段構建（Multi-stage Build）技術來創建最小化且安全的 Docker 映像檔，如何配置 Nginx 作為高性能的靜態檔案伺服器，以及如何使用 Docker Compose 簡化本地開發環境的設置和應用程式的啟動。這將有助於提升開發效率、確保環境一致性，並為未來的生產部署奠定堅實基礎。\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"2. Architecture / Design\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"前端應用程式的 Docker 容器化部署架構，旨在將前端應用程式的構建（Build）與運行（Run）環境分離，並透過 Nginx 提供高效的靜態檔案服務。這種設計模式確保了最終映像檔的輕量化、安全性與高性能。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"2.1 專案結構 (Project Structure)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"一個典型的容器化前端專案將包含以下核心檔案和目錄結構：\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\". # 專案根目錄\\n├── my-frontend-app/ # 前端應用程式目錄\\n│   ├── src/ # 原始碼\\n│   ├── public/ # 靜態資源\\n│   ├── package.json # NPM 依賴管理\\n│   ├── Dockerfile # Docker 構建檔案\\n│   └── nginx.conf # Nginx 伺服器配置檔案\\n└── docker-compose.yml # Docker Compose 配置檔案 (用於本地開發/多服務協調)\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"2.2 Dockerfile 設計 (Dockerfile Design) - 多階段構建 (Multi-stage Build)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"多階段構建是 Dockerfile 的一項關鍵特性，它允許在一個 Dockerfile 中定義多個 \",[\"$\",\"code\",null,{\"children\":\"FROM\"}],\" 指令，每個 \",[\"$\",\"code\",null,{\"children\":\"FROM\"}],\" 指令都代表一個構建階段。這樣做的好處是，最終的映像檔只包含運行應用程式所需的最小化組件，而不會包含構建時所需的龐大工具和依賴。這顯著減少了映像檔的大小，提升了安全性和部署速度。\"]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"2.2.1 第一階段：構建階段 (Build Stage)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"此階段的目標是安裝所有前端專案的開發依賴，並執行構建命令（例如 \",[\"$\",\"code\",null,{\"children\":\"npm run build\"}],\" 或 \",[\"$\",\"code\",null,{\"children\":\"yarn build\"}],\"），生成生產環境所需的靜態檔案。我們通常會選擇一個包含 Node.js 環境的基礎映像檔。\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-dockerfile\",\"children\":\"# Stage 1: Build the frontend application\\nFROM node:lts-alpine as builder\\n\\n# Set the working directory inside the container\\nWORKDIR /app\\n\\n# Copy package.json and package-lock.json (or yarn.lock) to leverage Docker cache\\nCOPY package*.json ./\\n\\n# Install dependencies\\nRUN npm install --silent\\n\\n# Copy the rest of the application code\\nCOPY . .\\n\\n# Build the application for production\\n# Replace 'npm run build' with your specific build command (e.g., 'ng build --configuration=production')\\nRUN npm run build\\n\\n# The build output will typically be in a 'dist' or 'build' folder\\n# For example, for React it's 'build', for Angular it's 'dist/\u003cproject-name\u003e'\\n# For this example, we assume the output is in 'dist'\\n\"}]}],\"\\n\",[\"$\",\"h4\",null,{\"children\":\"2.2.2 第二階段：運行階段 (Runtime Stage)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"此階段的目標是只包含運行前端應用程式所需的最小化環境，即一個輕量級的靜態檔案伺服器 Nginx。它將從第一階段複製構建好的靜態檔案，並配置 Nginx 來服務這些檔案。\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-dockerfile\",\"children\":\"# Stage 2: Serve the application with Nginx\\nFROM nginx:alpine\\n\\n# Copy the custom Nginx configuration file\\nCOPY nginx.conf /etc/nginx/conf.d/default.conf\\n\\n# Copy the built frontend application from the 'builder' stage\\n# Adjust '/app/dist' to your actual build output directory from Stage 1\\nCOPY --from=builder /app/dist /usr/share/nginx/html\\n\\n# Expose port 80 for Nginx\\nEXPOSE 80\\n\\n# Command to run Nginx when the container starts\\nCMD [\\\"nginx\\\", \\\"-g\\\", \\\"daemon off;\\\"]\\n\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"2.3 Nginx 配置 (Nginx Configuration) - \",[\"$\",\"code\",null,{\"children\":\"nginx.conf\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Nginx 作為一個高性能的 Web 伺服器，非常適合用來服務前端應用的靜態檔案。對於單頁應用程式（SPA），Nginx 的配置需要特別處理路由回退（Fallback Routing），以確保所有未匹配的路由都能指向 \",[\"$\",\"code\",null,{\"children\":\"index.html\"}],\"。\"]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-nginx\",\"children\":\"$17\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"2.4 Docker Compose 配置 (Docker Compose Configuration) - \",[\"$\",\"code\",null,{\"children\":\"docker-compose.yml\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Docker Compose 是一個用於定義和運行多容器 Docker 應用程式的工具。透過一個 YAML 檔案，您可以配置應用程式的服務、網路和儲存。對於本地部署，它極大地簡化了多個服務（例如前端、後端 API、資料庫）的協調與啟動。\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-yaml\",\"children\":\"# docker-compose.yml\\nversion: \\\"3.8\\\"\\n\\nservices:\\n  frontend:\\n    build:\\n      context: ./my-frontend-app # 指向 Dockerfile 所在的目錄\\n      dockerfile: Dockerfile\\n    ports:\\n      - \\\"80:80\\\" # 將主機的 80 埠映射到容器的 80 埠\\n    # volumes: # 僅在開發環境下考慮使用，生產環境不建議\\n    #   - ./my-frontend-app:/usr/share/nginx/html # 將本地程式碼掛載到容器，實現熱重載\\n    # environment: # 如果前端應用程式需要運行時環境變數\\n    #   - API_BASE_URL=http://localhost:3000\\n    restart: always # 容器退出後自動重啟\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"3. Prerequisites\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"在開始容器化前端應用程式之前，請確保您的開發環境已安裝以下工具：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Docker Desktop\"}],\" 或 \",[\"$\",\"strong\",null,{\"children\":\"Docker Engine\"}],\": 這是運行 Docker 容器的基礎。您可以從 \",[\"$\",\"a\",null,{\"href\":\"https://www.docker.com/get-started\",\"children\":\"Docker 官方網站\"}],\" 下載並安裝。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Node.js \u0026 npm/yarn\"}],\": 用於前端應用程式的開發和構建。雖然 Dockerfile 會處理容器內的 Node.js 環境，但在本地開發時仍需要。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"一個前端應用程式\"}],\": 任何基於 React, Angular, Vue 或其他框架的單頁應用程式。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"4. Implementation / Code Example\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"以下將提供一個完整的實作範例，假設您有一個名為 \",[\"$\",\"code\",null,{\"children\":\"my-frontend-app\"}],\" 的前端專案。\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.1 專案設置\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"首先，確保您的專案結構如 \",[\"$\",\"code\",null,{\"children\":\"2.1 專案結構\"}],\" 中所示。在 \",[\"$\",\"code\",null,{\"children\":\"my-frontend-app\"}],\" 目錄下，您應該有您的前端程式碼、\",[\"$\",\"code\",null,{\"children\":\"package.json\"}],\" 等。然後，創建 \",[\"$\",\"code\",null,{\"children\":\"Dockerfile\"}],\" 和 \",[\"$\",\"code\",null,{\"children\":\"nginx.conf\"}],\" 檔案。\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"4.2 \",[\"$\",\"code\",null,{\"children\":\"my-frontend-app/Dockerfile\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"請參考 \",[\"$\",\"code\",null,{\"children\":\"2.2 Dockerfile 設計\"}],\" 中的多階段構建範例，將其內容複製到您的 \",[\"$\",\"code\",null,{\"children\":\"my-frontend-app/Dockerfile\"}],\" 檔案中。請務必根據您的前端框架調整 \",[\"$\",\"code\",null,{\"children\":\"RUN npm run build\"}],\" 命令和 \",[\"$\",\"code\",null,{\"children\":\"COPY --from=builder /app/dist\"}],\" 的路徑。\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"4.3 \",[\"$\",\"code\",null,{\"children\":\"my-frontend-app/nginx.conf\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"請參考 \",[\"$\",\"code\",null,{\"children\":\"2.3 Nginx 配置\"}],\" 中的範例，將其內容複製到您的 \",[\"$\",\"code\",null,{\"children\":\"my-frontend-app/nginx.conf\"}],\" 檔案中。此配置已針對 SPA 進行優化，並包含基本的快取和 Gzip 壓縮。\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"4.4 \",[\"$\",\"code\",null,{\"children\":\"docker-compose.yml\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"在專案的根目錄（與 \",[\"$\",\"code\",null,{\"children\":\"my-frontend-app\"}],\" 同級）創建 \",[\"$\",\"code\",null,{\"children\":\"docker-compose.yml\"}],\" 檔案，並複製 \",[\"$\",\"code\",null,{\"children\":\"2.4 Docker Compose 配置\"}],\" 中的內容。確保 \",[\"$\",\"code\",null,{\"children\":\"context\"}],\" 指向正確的前端應用程式目錄。\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.5 本地部署工作流 (Local Deployment Workflow)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"完成上述檔案設置後，您可以按照以下步驟在本地部署您的前端應用程式：\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"打開終端機\"}],\"：導航到包含 \",[\"$\",\"code\",null,{\"children\":\"docker-compose.yml\"}],\" 檔案的專案根目錄。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"構建並啟動容器\"}],\"：執行以下命令。\",\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-bash\",\"children\":\"docker-compose up --build -d\\n\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"up\"}],\": 啟動服務。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"--build\"}],\": 強制重新構建映像檔，確保使用最新的 \",[\"$\",\"code\",null,{\"children\":\"Dockerfile\"}],\" 和程式碼。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"-d\"}],\": 在後台運行容器（detached mode）。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"驗證服務\"}],\"：等待 Docker 映像檔構建完成並啟動容器。您可以使用 \",[\"$\",\"code\",null,{\"children\":\"docker-compose ps\"}],\" 命令查看容器狀態。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"訪問應用程式\"}],\"：打開您的瀏覽器，訪問 \",[\"$\",\"code\",null,{\"children\":\"http://localhost\"}],\" (如果 \",[\"$\",\"code\",null,{\"children\":\"docker-compose.yml\"}],\" 中映射的是 80 埠)。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"停止與清理\"}],\"：當您完成開發或測試後，可以執行以下命令停止並移除容器、網路和卷。\",\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-bash\",\"children\":\"docker-compose down\\n\"}]}],\"\\n\",\"如果您想移除所有映像檔，可以執行 \",[\"$\",\"code\",null,{\"children\":\"docker-compose down --rmi all\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"5. Parameters / API Reference\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"此處主要涉及 Dockerfile 指令、Nginx 配置指令和 Docker Compose 服務配置。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"5.1 Dockerfile 關鍵指令\"}],\"\\n\",[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"指令\"}],[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"描述\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"FROM\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"指定基礎映像檔。多階段構建中會多次使用。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"WORKDIR\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"設定容器內的工作目錄。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"COPY\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"將主機上的檔案或目錄複製到容器內。\",[\"$\",\"code\",null,{\"children\":\"--from\"}],\" 參數用於從其他構建階段複製檔案。\"]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"RUN\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"在當前映像檔層中執行命令。常用於安裝依賴、構建應用程式。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"EXPOSE\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"聲明容器在運行時監聽的埠號。這是一個文檔說明，不實際發布埠號。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"CMD\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"提供容器啟動時的預設執行命令。如果 Dockerfile 中有多個 \",[\"$\",\"code\",null,{\"children\":\"CMD\"}],\"，只有最後一個生效。\"]}]]}]]}]]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"5.2 Nginx \",[\"$\",\"code\",null,{\"children\":\"nginx.conf\"}],\" 關鍵配置\"]}],\"\\n\",[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"配置項\"}],[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"描述\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"listen\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"Nginx 監聽的埠號。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"root\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"靜態檔案的根目錄。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"index\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"預設的索引檔案名稱。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"location /\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"處理所有請求的區塊。\",[\"$\",\"code\",null,{\"children\":\"try_files $uri $uri/ /index.html;\"}],\" 對於 SPA 至關重要，它會嘗試查找檔案，如果找不到則回退到 \",[\"$\",\"code\",null,{\"children\":\"index.html\"}],\"。\"]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"gzip on;\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"啟用 Gzip 壓縮。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"expires\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"設定 HTTP 響應頭中的 \",[\"$\",\"code\",null,{\"children\":\"Expires\"}],\" 和 \",[\"$\",\"code\",null,{\"children\":\"Cache-Control\"}],\"，控制瀏覽器快取。\"]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"add_header\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"添加自定義的 HTTP 響應頭，常用於安全性配置。\"}]]}]]}]]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"5.3 Docker Compose \",[\"$\",\"code\",null,{\"children\":\"docker-compose.yml\"}],\" 關鍵配置\"]}],\"\\n\",[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"配置項\"}],[\"$\",\"th\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"描述\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"version\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"Docker Compose 檔案格式版本。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"services\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"定義應用程式中的各個服務。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"build\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"指定如何構建服務的映像檔。\",[\"$\",\"code\",null,{\"children\":\"context\"}],\" 指向 \",[\"$\",\"code\",null,{\"children\":\"Dockerfile\"}],\" 所在目錄，\",[\"$\",\"code\",null,{\"children\":\"dockerfile\"}],\" 指定 \",[\"$\",\"code\",null,{\"children\":\"Dockerfile\"}],\" 名稱。\"]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"ports\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"將主機埠號映射到容器埠號。格式為 \",[\"$\",\"code\",null,{\"children\":\"HOST:CONTAINER\"}],\"。\"]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"volumes\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"將主機路徑或具名卷掛載到容器內。常用於開發時的程式碼同步。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"environment\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":\"設定容器內的環境變數。\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"$\",\"code\",null,{\"children\":\"restart\"}]}],[\"$\",\"td\",null,{\"style\":{\"textAlign\":\"left\"},\"children\":[\"定義容器退出後的重啟策略（例如 \",[\"$\",\"code\",null,{\"children\":\"always\"}],\", \",[\"$\",\"code\",null,{\"children\":\"on-failure\"}],\"）。\"]}]]}]]}]]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"6. Notes \u0026 Best Practices\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"多階段構建的優勢\"}],\"：始終使用多階段構建。這不僅能大幅縮小最終映像檔的體積，還能減少不必要的依賴和潛在的安全漏洞，因為運行時映像檔只包含必要的組件。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Nginx 配置優化\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"SPA 路由回退\"}],\"：\",[\"$\",\"code\",null,{\"children\":\"try_files $uri $uri/ /index.html;\"}],\" 是 SPA 部署的關鍵。它確保了無論用戶訪問哪個前端路由，Nginx 都能正確地返回 \",[\"$\",\"code\",null,{\"children\":\"index.html\"}],\"，讓前端路由器接管。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"快取策略\"}],\"：為靜態資源（JS, CSS, 圖片等）配置合理的 \",[\"$\",\"code\",null,{\"children\":\"expires\"}],\" 和 \",[\"$\",\"code\",null,{\"children\":\"Cache-Control\"}],\" 頭，可以顯著提升應用程式的載入速度和用戶體驗。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Gzip 壓縮\"}],\"：啟用 Gzip 壓縮可以減少傳輸的資料量，尤其對於大型 JS/CSS 檔案效果顯著。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"安全性頭\"}],\"：添加 \",[\"$\",\"code\",null,{\"children\":\"X-Frame-Options\"}],\", \",[\"$\",\"code\",null,{\"children\":\"X-Content-Type-Options\"}],\", \",[\"$\",\"code\",null,{\"children\":\"X-XSS-Protection\"}],\" 等 HTTP 安全性頭，可以增強應用程式的安全性。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"環境變數管理\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"前端應用程式通常需要在運行時獲取不同的環境變數（例如 API 服務的 URL）。避免將敏感資訊硬編碼到程式碼中。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"對於 Docker 容器，可以透過 \",[\"$\",\"code\",null,{\"children\":\"docker-compose.yml\"}],\" 的 \",[\"$\",\"code\",null,{\"children\":\"environment\"}],\" 區塊或 Dockerfile 中的 \",[\"$\",\"code\",null,{\"children\":\"ARG\"}],\"/\",[\"$\",\"code\",null,{\"children\":\"ENV\"}],\" 指令來注入環境變數。在 Nginx 配置中，可以利用 \",[\"$\",\"code\",null,{\"children\":\"envsubst\"}],\" 在容器啟動時替換 Nginx 配置中的變數。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"本地開發與熱重載\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"在開發階段，可以考慮在 \",[\"$\",\"code\",null,{\"children\":\"docker-compose.yml\"}],\" 中使用 \",[\"$\",\"code\",null,{\"children\":\"volumes\"}],\" 將本地程式碼目錄掛載到容器內，並結合前端開發伺服器的熱重載功能，實現程式碼修改後容器內自動更新。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"然而，在生產環境中應避免使用 \",[\"$\",\"code\",null,{\"children\":\"volumes\"}],\" 掛載程式碼，因為這會增加部署的複雜性並可能引入不一致性。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"映像檔標籤 (Image Tagging)\"}],\"：為您的 Docker 映像檔使用有意義的標籤（例如 \",[\"$\",\"code\",null,{\"children\":\"v1.0.0\"}],\", \",[\"$\",\"code\",null,{\"children\":\"latest\"}],\", \",[\"$\",\"code\",null,{\"children\":\"commit-sha\"}],\"），以便於版本管理和回溯。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"安全性考量\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"使用官方的、受信任的基礎映像檔（例如 \",[\"$\",\"code\",null,{\"children\":\"node:lts-alpine\"}],\", \",[\"$\",\"code\",null,{\"children\":\"nginx:alpine\"}],\"）。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"定期更新基礎映像檔，以獲取最新的安全補丁。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"避免在最終映像檔中包含不必要的工具和依賴。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"7. 為什麼選擇這種方式？\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"將前端應用程式進行 Docker 容器化並透過 Nginx 部署，是現代 Web 開發中的一個黃金標準。選擇這種方式，主要基於以下幾個不可或缺的優勢：\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"環境一致性\"}],\"：Docker 容器提供了一個隔離且標準化的運行環境，確保了應用程式從開發、測試到生產環境的一致性。這極大地減少了因環境差異導致的問題，加速了開發與部署流程。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"高效能服務\"}],\"：Nginx 作為一個輕量級且高效能的 Web 伺服器，非常適合服務前端應用的靜態檔案。其優化的快取機制、Gzip 壓縮以及對 SPA 路由的良好支持，能夠顯著提升應用程式的載入速度和用戶體驗。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"資源優化與安全性\"}],\"：透過多階段構建，最終的 Docker 映像檔只包含運行應用程式所需的最小化組件，不包含構建工具和開發依賴。這不僅使得映像檔體積更小，減少了儲存和傳輸成本，也降低了潛在的安全攻擊面。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"簡化部署與擴展\"}],\"：容器化的應用程式易於部署到任何支援 Docker 的環境，無論是本地開發、測試伺服器還是雲端平台（如 Kubernetes, AWS ECS）。Docker Compose 進一步簡化了本地多服務應用程式的啟動和管理，為未來的水平擴展奠定了基礎。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"標準化工作流\"}],\"：這種模式提供了一個清晰、可重複的部署工作流，有助於團隊成員之間的協作，並能輕鬆整合到 CI/CD 流水線中，實現自動化測試和部署。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"參考資料\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[1] OneUptime. (2026, February 2). \",[\"$\",\"em\",null,{\"children\":\"How to Use Multi-Stage Docker Builds\"}],\". Retrieved from \",[\"$\",\"a\",null,{\"href\":\"https://oneuptime.com/blog/post/2026-02-02-docker-multi-stage-builds/view\",\"children\":\"https://oneuptime.com/blog/post/2026-02-02-docker-multi-stage-builds/view\"}]]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[2] DEV Community. (2025, October 7). \",[\"$\",\"em\",null,{\"children\":\"Guide to Containerizing a Modern JavaScript SPA (Vue/Vite/React) with a Multi-Stage Nginx Build\"}],\". Retrieved from \",[\"$\",\"a\",null,{\"href\":\"https://dev.to/it-wibrc/guide-to-containerizing-a-modern-javascript-spa-vuevitereact-with-a-multi-stage-nginx-build-1lma\",\"children\":\"https://dev.to/it-wibrc/guide-to-containerizing-a-modern-javascript-spa-vuevitereact-with-a-multi-stage-nginx-build-1lma\"}]]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[3] Telerik. (2025, June 4). \",[\"$\",\"em\",null,{\"children\":\"Deploying Angular Apps with NGINX and Docker\"}],\". Retrieved from \",[\"$\",\"a\",null,{\"href\":\"https://www.telerik.com/blogs/deploying-angular-apps-nginx-docker\",\"children\":\"https://www.telerik.com/blogs/deploying-angular-apps-nginx-docker\"}]]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[4] Docker. (n.d.). \",[\"$\",\"em\",null,{\"children\":\"Get Started with Docker\"}],\". Retrieved from \",[\"$\",\"a\",null,{\"href\":\"https://www.docker.com/get-started\",\"children\":\"https://www.docker.com/get-started\"}]]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[5] Heroku Dev Center. (2025, November 5). \",[\"$\",\"em\",null,{\"children\":\"Local Development with Docker Compose\"}],\". Retrieved from \",[\"$\",\"a\",null,{\"href\":\"https://devcenter.heroku.com/articles/local-development-with-docker-compose\",\"children\":\"https://devcenter.heroku.com/articles/local-development-with-docker-compose\"}]]}],\"\\n\"]}]]\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"14:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"【系統部署】前端應用程式的 Docker 容器化與本地部署指南 | 子yee 萬事屋 | 子yee\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"一份詳盡的前端應用程式 Docker 容器化指南，涵蓋多階段構建、Nginx 優化配置及本地部署工作流，確保開發與生產環境一致性。\"}],[\"$\",\"meta\",\"2\",{\"name\":\"author\",\"content\":\"子yee\"}],[\"$\",\"meta\",\"3\",{\"name\":\"keywords\",\"content\":\"子yee 萬事屋, 台股查詢, 自選股, 技術小工具, 股票資訊平台, 技術顧問, 自動化工具\"}],[\"$\",\"meta\",\"4\",{\"name\":\"google-site-verification\",\"content\":\"adHIcDQiasHY4YzPlrpmSSPKl7Oj1WxrPJ_4GV4PQcM\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:title\",\"content\":\"【系統部署】前端應用程式的 Docker 容器化與本地部署指南\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:description\",\"content\":\"一份詳盡的前端應用程式 Docker 容器化指南，涵蓋多階段構建、Nginx 優化配置及本地部署工作流，確保開發與生產環境一致性。\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image\",\"content\":\"https://qwer820921.github.io/images/img15.jpg\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:image:height\",\"content\":\"630\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:image:alt\",\"content\":\"【系統部署】前端應用程式的 Docker 容器化與本地部署指南\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:title\",\"content\":\"【系統部署】前端應用程式的 Docker 容器化與本地部署指南\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:description\",\"content\":\"一份詳盡的前端應用程式 Docker 容器化指南，涵蓋多階段構建、Nginx 優化配置及本地部署工作流，確保開發與生產環境一致性。\"}],[\"$\",\"meta\",\"15\",{\"name\":\"twitter:image\",\"content\":\"https://qwer820921.github.io/images/img15.jpg\"}],[\"$\",\"link\",\"16\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"64x64\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"e:{\"metadata\":\"$14:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>