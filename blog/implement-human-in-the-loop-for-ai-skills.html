<!DOCTYPE html><html lang="zh-Hant"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/be607b33620c6e00.css" data-precedence="next"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/739e5c607d9731d5.css" data-precedence="next"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/4bb1c53d4d41ca49.css" data-precedence="next"/><link rel="stylesheet" href="https://qwer820921.github.io/_next/static/css/0105f7c97f16220d.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="https://qwer820921.github.io/_next/static/chunks/webpack-6eefbc0fef8fd205.js"/><script src="https://qwer820921.github.io/_next/static/chunks/4bd1b696-e100a0b1879d5e6b.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/1684-9b53760636e10952.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/main-app-c0d2570cf703bee2.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/8482-5637f60b9e0ae224.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/app/layout-898a3761c5f29253.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/6874-cfa829be98f8140c.js" async=""></script><script src="https://qwer820921.github.io/_next/static/chunks/app/blog/%5Bslug%5D/page-c93c0e23c9658930.js" async=""></script><link rel="preload" href="https://qwer820921.github.io/_next/static/chunks/2990.dad4388d14b132db.js" as="script" fetchPriority="low"/><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-CCKVESHCQ1" as="script"/><link rel="preload" href="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2709303513603814" as="script" crossorigin=""/><link rel="icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/logo192.png"/><link rel="manifest" href="/manifest.json"/><link rel="preload" href="/logo192.png" as="image"/><title>【安全機制】為 AI Skill 添加「人類授權層 (Human-in-the-loop)」與權限控制 | 子yee 萬事屋 | 子yee</title><meta name="description" content="深入探討如何在 Agentic AI 系統中實作 Human-in-the-loop (HITL) 機制，透過 Middleware 攔截、異步審批工作流與權限控制，確保 AI Skill 執行的安全性與合規性。"/><meta name="keywords" content="子yee 萬事屋, 台股查詢, 自選股, 技術小工具, 股票資訊平台, 技術顧問, 自動化工具"/><meta name="google-site-verification" content="adHIcDQiasHY4YzPlrpmSSPKl7Oj1WxrPJ_4GV4PQcM"/><meta property="og:title" content="【安全機制】為 AI Skill 添加「人類授權層 (Human-in-the-loop)」與權限控制"/><meta property="og:description" content="深入探討如何在 Agentic AI 系統中實作 Human-in-the-loop (HITL) 機制，透過 Middleware 攔截、異步審批工作流與權限控制，確保 AI Skill 執行的安全性與合規性。"/><meta property="og:image" content="https://qwer820921.github.io/images/img15.jpg"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:alt" content="【安全機制】為 AI Skill 添加「人類授權層 (Human-in-the-loop)」與權限控制"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="【安全機制】為 AI Skill 添加「人類授權層 (Human-in-the-loop)」與權限控制"/><meta name="twitter:description" content="深入探討如何在 Agentic AI 系統中實作 Human-in-the-loop (HITL) 機制，透過 Middleware 攔截、異步審批工作流與權限控制，確保 AI Skill 執行的安全性與合規性。"/><meta name="twitter:image" content="https://qwer820921.github.io/images/img15.jpg"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="https://qwer820921.github.io/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><main class="container-fluid mt-5 p-0"><article class="container py-5"><div class="row justify-content-center"><div class="col-12 col-lg-8"><div class="mb-4"><a class="btn btn-outline-secondary d-inline-flex align-items-center gap-2" href="/blog"><span>←</span>回到文章列表</a></div><div class="card shadow-sm border-0"><div class="card-body p-4 p-md-5"><header class="mb-5 pb-4 border-bottom"><h1 class="fw-bold mb-3 display-5">【安全機制】為 AI Skill 添加「人類授權層 (Human-in-the-loop)」與權限控制</h1><div class="text-muted d-flex align-items-center gap-2"><i class="bi bi-calendar3"></i>2026-02-11</div></header><div class="blogContent_blogContent__VY_R4"><h1>【安全機制】為 AI Skill 添加「人類授權層 (Human-in-the-loop)」與權限控制</h1>
<p><strong>作者：</strong> Yee
<strong>日期：</strong> 2026年2月11日</p>
<hr/>
<h2>1. Overview</h2>
<p>隨著 AI Agent 的能力日益增強，它們被賦予了執行複雜任務和存取敏感系統的權限。然而，這也帶來了新的安全挑戰：如何確保 AI Agent 不會執行危險、不當或未經授權的操作？例如，一個 AI Agent 可能會錯誤地刪除資料庫、進行未經批准的金融交易，或者在遊戲中執行破壞性行為。傳統的程式安全機制不足以完全應對 LLM 可能產生的「幻覺（Hallucination）」或「提示詞注入（Prompt Injection）」攻擊 [1]。</p>
<p>為了解決這些問題，**「人類授權層（Human-in-the-loop, HITL）」**成為 Agentic AI 系統中不可或缺的安全機制。HITL 旨在將人類的判斷和監督整合到自動化流程的關鍵決策點，特別是在 AI Agent 嘗試執行高風險或敏感操作之前 [2]。它透過引入一個「確認機制」，確保所有可能產生重大影響的 AI Skill 執行都必須經過人類的明確批准。</p>
<p>本文件將深入探討如何在 AI Skill 的執行流程中實作一個強健的 HITL 機制。我們將介紹如何利用 <strong>Middleware（中介層）<strong>模式攔截 AI 的工具呼叫（Tool Call），建立一個</strong>異步審批工作流（Asynchronous Approval Workflow）</strong>，並整合外部通知系統（如 LINE Notify 或 Discord Webhook）來實現遠端批准。這不僅能大幅提升 AI 應用的安全性與責任歸屬，也能滿足企業在金融、醫療等受監管行業的合規性要求。</p>
<h2>2. Architecture / Design</h2>
<p>實作 Human-in-the-loop (HITL) 機制的核心在於在 AI Agent 決定執行一個 Skill 與該 Skill 實際執行之間，插入一個可控的「審批閘門」。這個閘門需要能夠攔截請求、通知人類、等待批准，並在收到批准後才放行執行。以下是其架構設計的核心模式 [3]。</p>
<h3>2.1 攔截器模式 (The Interceptor Pattern)</h3>
<ul>
<li><strong>核心思想</strong>：在 AI Agent 框架（如 LangChain、Semantic Kernel）中，當 AI 決定呼叫一個外部工具或執行一個 Native Function 時，不應立即執行。而是在這個「呼叫」與「執行」之間，插入一個自定義的攔截器（Interceptor）或過濾器（Filter） [4]。</li>
<li><strong>Middleware/Filters</strong>：這個攔截器作為一個中介層，負責檢查即將執行的 Skill 是否被標記為「敏感」或「需要人工審批」。如果符合條件，它將阻止 Skill 的直接執行。</li>
<li><strong>掛起狀態 (State Suspension)</strong>：當攔截器阻止執行時，AI Agent 的當前執行狀態（包括其思考過程、上下文、即將執行的 Skill 及其參數）需要被<strong>持久化（Check-pointing）</strong>。Agent 的執行將被暫停，進入等待（Pending）模式，直到收到人類的審批結果 [5]。</li>
</ul>
<h3>2.2 異步審批工作流 (Asynchronous Approval Workflow)</h3>
<p>這是 HITL 機制的關鍵部分，它定義了人類介入的流程：</p>
<ol>
<li><strong>AI 觸發敏感操作 (Trigger)</strong>：AI Agent 根據其推理結果，產生一個需要執行敏感操作的意圖，例如 <code>SellStock(symbol=&quot;AAPL&quot;, amount=100)</code> 或 <code>DeleteDatabase(dbName=&quot;Production&quot;)</code>。</li>
<li><strong>攔截與識別 (Intercept &amp; Identify)</strong>：<!-- -->
<ul>
<li>攔截器捕獲到這個 Skill 呼叫。它會檢查該 Skill 的元數據（Metadata），例如 <code>[RiskLevel(&quot;High&quot;)]</code> 或 <code>[RequiresApproval(true)]</code>，判斷其是否需要人工審批。</li>
<li>如果需要審批，攔截器會提取 Skill 的詳細資訊（名稱、參數、AI 的推理過程等），並將其與當前 Agent 的會話 ID 一起儲存到一個**持久化層（Persistence Layer）**中。</li>
</ul>
</li>
<li><strong>發送通知 (Notify)</strong>：<!-- -->
<ul>
<li>系統會透過一個通知服務，向預定義的管理者或審批人發送審批請求。通知可以透過多種管道發送，例如：<!-- -->
<ul>
<li><strong>LINE Notify</strong>：發送包含操作詳情和「批准/拒絕」按鈕的訊息。</li>
<li><strong>Discord Webhook</strong>：發送嵌入式訊息（Embed Message），提供互動式按鈕。</li>
<li><strong>Email/Slack</strong>：發送包含審批連結的通知。</li>
</ul>
</li>
<li>通知中應包含一個唯一的<strong>審批 ID (Approval ID)</strong>，用於後續的回調。</li>
</ul>
</li>
<li><strong>人類審批 (Human Approval)</strong>：<!-- -->
<ul>
<li>管理者收到通知後，審閱 AI 提出的操作請求。基於對業務影響、風險和 AI 推理的理解，管理者決定「批准」或「拒絕」該操作。</li>
<li>管理者透過點擊通知中的按鈕或訪問特定的審批介面，提交審批結果。</li>
</ul>
</li>
<li><strong>接收回調與恢復 (Receive Callback &amp; Resume)</strong>：<!-- -->
<ul>
<li>系統接收到來自通知服務的回調（Callback），其中包含審批 ID 和審批結果（批准/拒絕）。</li>
<li>系統根據審批 ID 從持久化層中檢索出之前掛起的 Agent 狀態。</li>
<li>如果審批結果是「批准」，Agent 的執行將從掛起點恢復，並執行原定的 Skill。如果審批結果是「拒絕」，則 Skill 執行被中止，Agent 可能會收到一個錯誤訊息，並根據其邏輯重新規劃或通知使用者 [6]。</li>
</ul>
</li>
</ol>
<h3>2.3 權限控制與角色管理</h3>
<p>除了 HITL，細粒度的權限控制也是確保 AI Agent 安全的關鍵：</p>
<ul>
<li><strong>基於角色的存取控制 (RBAC)</strong>：定義不同的使用者角色（例如：開發者、業務經理、安全審計員），並為每個角色分配不同的審批權限。例如，只有特定的安全團隊成員才能批准資料庫刪除操作。</li>
<li><strong>操作敏感度分級</strong>：為每個 Skill 定義一個敏感度級別（例如：低、中、高）。只有達到特定敏感度級別的 Skill 才需要觸發 HITL 流程。</li>
<li><strong>審批策略</strong>：可以設定多級審批（例如：需要兩人同時批准）或基於金額的審批（例如：交易金額超過 $10000 需要批准）。</li>
</ul>
<h2>3. Prerequisites</h2>
<p>要實作一個帶有 HITL 的 AI Skill 安全機制，您需要具備以下環境和知識：</p>
<ul>
<li><strong>AI Agent 框架</strong>：熟悉您選擇的 AI Agent 框架，例如 LangChain、LangGraph、Semantic Kernel 或自定義 Agent 框架。</li>
<li><strong>程式語言</strong>：熟悉 Python (LangChain/LangGraph) 或 C# (Semantic Kernel) 等程式語言。</li>
<li><strong>Web 服務開發</strong>：需要具備開發 Web API 的能力，用於接收通知服務的回調。</li>
<li><strong>持久化層</strong>：熟悉資料庫（如 PostgreSQL, MongoDB）或鍵值儲存（如 Redis）的使用，用於儲存 Agent 狀態和審批請求。</li>
<li><strong>通知服務 API</strong>：了解 LINE Notify、Discord Webhook 或其他通知服務的 API 整合。</li>
<li><strong>非同步程式設計</strong>：理解 <code>async/await</code> 等非同步程式設計模式，以處理異步審批工作流。</li>
</ul>
<h2>4. Implementation / Code Example</h2>
<p>本節將提供一個概念性的 Python 程式碼範例，展示如何在一個簡化的 AI Agent 框架中實作 HITL。我們將模擬一個 <code>SellStock</code> Skill，並在執行前觸發人工審批。</p>
<h3>4.1 模擬 AI Agent 框架與 Skill 定義</h3>
<pre><code class="language-python">import uuid
import time
import json
from enum import Enum
from typing import Dict, Any, Callable, Optional

# 模擬外部通知服務 (例如 LINE Notify 或 Discord Webhook)
# 在實際應用中，這裡會發送 HTTP 請求到 LINE/Discord API
def send_approval_notification(approval_id: str, action_details: Dict[str, Any]):
    print(f&quot;\n--- 發送審批通知 ---&quot;)
    print(f&quot;審批 ID: {approval_id}&quot;)
    print(f&quot;請求操作: {action_details[&#x27;skill_name&#x27;]}&quot;)
    print(f&quot;參數: {json.dumps(action_details[&#x27;params&#x27;], indent=2)}&quot;)
    print(f&quot;請訪問此連結批准或拒絕: http://your-approval-service.com/approve/{approval_id}&quot;)
    print(f&quot;---------------------&quot;)

# 模擬一個持久化層來儲存掛起的請求
# 在實際應用中，這會是 Redis 或資料庫
pending_approvals: Dict[str, Dict[str, Any]] = {}

class ApprovalStatus(Enum):
    PENDING = &quot;PENDING&quot;
    APPROVED = &quot;APPROVED&quot;
    REJECTED = &quot;REJECTED&quot;
    EXPIRED = &quot;EXPIRED&quot;

class AISkill:
    def __init__(self, name: str, func: Callable, requires_approval: bool = False):
        self.name = name
        self.func = func
        self.requires_approval = requires_approval

    def execute(self, **kwargs):
        print(f&quot;執行 Skill: {self.name} with params: {kwargs}&quot;)
        return self.func(**kwargs)

class AIAgent:
    def __init__(self, name: str):
        self.name = name
        self.skills: Dict[str, AISkill] = {}

    def add_skill(self, skill: AISkill):
        self.skills[skill.name] = skill

    async def execute_skill(self, skill_name: str, **kwargs) -&gt; Any:
        skill = self.skills.get(skill_name)
        if not skill:
            raise ValueError(f&quot;Skill &#x27;{skill_name}&#x27; not found.&quot;)

        if skill.requires_approval:
            print(f&quot;\n[Agent] Skill &#x27;{skill_name}&#x27; 需要人工審批。&quot;)
            approval_id = str(uuid.uuid4())
            action_details = {
                &quot;skill_name&quot;: skill_name,
                &quot;params&quot;: kwargs,
                &quot;agent_name&quot;: self.name,
                &quot;status&quot;: ApprovalStatus.PENDING.value,
                &quot;timestamp&quot;: time.time()
            }
            pending_approvals[approval_id] = action_details
            send_approval_notification(approval_id, action_details)

            # 模擬等待人類審批
            print(f&quot;[Agent] 等待人類審批 (ID: {approval_id})...&quot;)
            while pending_approvals[approval_id][&quot;status&quot;] == ApprovalStatus.PENDING.value:
                await asyncio.sleep(2) # 每 2 秒檢查一次

            if pending_approvals[approval_id][&quot;status&quot;] == ApprovalStatus.APPROVED.value:
                print(f&quot;[Agent] Skill &#x27;{skill_name}&#x27; 已獲批准，正在執行...&quot;)
                result = skill.execute(**kwargs)
                del pending_approvals[approval_id] # 清理
                return result
            else:
                print(f&quot;[Agent] Skill &#x27;{skill_name}&#x27; 被拒絕或過期，中止執行。&quot;)
                del pending_approvals[approval_id] # 清理
                return f&quot;操作 &#x27;{skill_name}&#x27; 被拒絕或過期。&quot;
        else:
            print(f&quot;[Agent] Skill &#x27;{skill_name}&#x27; 無需審批，直接執行。&quot;)
            return skill.execute(**kwargs)

# 模擬一個後端服務來處理審批回調
# 在實際應用中，這會是一個 Flask/FastAPI/ASP.NET Core 的 endpoint
async def simulate_approval_service(approval_id: str, status: ApprovalStatus):
    if approval_id in pending_approvals:
        pending_approvals[approval_id][&quot;status&quot;] = status.value
        print(f&quot;\n[Approval Service] 審批 ID {approval_id} 狀態更新為 {status.value}&quot;)
    else:
        print(f&quot;[Approval Service] 錯誤: 審批 ID {approval_id} 不存在或已處理。&quot;)

# 實際的 Skill 函數
def sell_stock_func(symbol: str, amount: int):
    print(f&quot;--- 執行 SellStock: 賣出 {amount} 股 {symbol} ---&quot;)
    # 這裡會是實際的交易邏輯
    return f&quot;成功賣出 {amount} 股 {symbol}。&quot;

def get_stock_price_func(symbol: str):
    print(f&quot;--- 執行 GetStockPrice: 獲取 {symbol} 股價 ---&quot;)
    # 這裡會是實際的股價查詢邏輯
    return f&quot;{symbol} 當前股價為 $175.50。&quot;

# 主程式邏輯
import asyncio

async def main():
    my_agent = AIAgent(&quot;FinancialAgent&quot;)

    # 添加需要審批的 Skill
    my_agent.add_skill(AISkill(&quot;SellStock&quot;, sell_stock_func, requires_approval=True))
    # 添加無需審批的 Skill
    my_agent.add_skill(AISkill(&quot;GetStockPrice&quot;, get_stock_price_func, requires_approval=False))

    print(&quot;\n--- 測試無需審批的 Skill ---&quot;)
    price_result = await my_agent.execute_skill(&quot;GetStockPrice&quot;, symbol=&quot;MSFT&quot;)
    print(f&quot;結果: {price_result}&quot;)

    print(&quot;\n--- 測試需要審批的 Skill ---&quot;)
    # 模擬 AI 嘗試賣出股票
    sell_task = asyncio.create_task(my_agent.execute_skill(&quot;SellStock&quot;, symbol=&quot;GOOG&quot;, amount=50))

    # 模擬人類在收到通知後進行批准
    await asyncio.sleep(5) # 等待通知發送
    # 假設我們知道審批 ID (從 pending_approvals 中獲取第一個)
    if pending_approvals:
        first_approval_id = list(pending_approvals.keys())[0]
        print(f&quot;\n[Main] 模擬人類批准操作 (ID: {first_approval_id})...&quot;)
        await simulate_approval_service(first_approval_id, ApprovalStatus.APPROVED)

    sell_result = await sell_task
    print(f&quot;結果: {sell_result}&quot;)

    print(&quot;\n--- 測試需要審批但被拒絕的 Skill ---&quot;)
    reject_task = asyncio.create_task(my_agent.execute_skill(&quot;SellStock&quot;, symbol=&quot;AMZN&quot;, amount=10))
    await asyncio.sleep(5)
    if pending_approvals:
        second_approval_id = list(pending_approvals.keys())[0]
        print(f&quot;\n[Main] 模擬人類拒絕操作 (ID: {second_approval_id})...&quot;)
        await simulate_approval_service(second_approval_id, ApprovalStatus.REJECTED)
    reject_result = await reject_task
    print(f&quot;結果: {reject_result}&quot;)

if __name__ == &quot;__main__&quot;:
    asyncio.run(main())
</code></pre>
<h3>4.2 程式碼說明</h3>
<ul>
<li><strong><code>send_approval_notification</code></strong>：模擬向外部通知服務發送請求，其中包含審批 ID 和操作詳情。在實際應用中，這會是一個 HTTP POST 請求到 LINE Notify 或 Discord Webhook API。</li>
<li><strong><code>pending_approvals</code></strong>：一個字典，模擬持久化層，用於儲存所有待審批的請求。鍵是唯一的 <code>approval_id</code>，值是包含 Skill 名稱、參數、狀態等資訊的字典。</li>
<li><strong><code>AISkill</code> 類別</strong>：代表一個 AI Agent 可以執行的技能。新增了 <code>requires_approval</code> 屬性來標記該 Skill 是否需要人工審批。</li>
<li><strong><code>AIAgent</code> 類別</strong>：<code>execute_skill</code> 方法是核心。當 <code>skill.requires_approval</code> 為 <code>True</code> 時，它會生成一個 <code>approval_id</code>，將請求資訊儲存到 <code>pending_approvals</code>，並呼叫 <code>send_approval_notification</code>。然後進入一個循環，等待 <code>pending_approvals</code> 中對應請求的狀態更新。</li>
<li><strong><code>simulate_approval_service</code></strong>：模擬一個後端 API 端點，接收來自通知服務的回調，並更新 <code>pending_approvals</code> 中請求的狀態。</li>
<li><strong><code>main</code> 函數</strong>：展示了如何創建 Agent、添加 Skill，並測試需要審批和無需審批的 Skill。它還模擬了人類批准和拒絕的過程。</li>
</ul>
<h2>5. Parameters / API Reference</h2>
<p>本節將基於上述範例，抽象出實作 HITL 機制時可能涉及的關鍵參數和介面。</p>
<h3>5.1 <code>AISkill</code> 類別參數</h3>
<p>| 參數名稱            | 類型       | 描述                                                |
| :------------------ | :--------- | :-------------------------------------------------- |
| <code>name</code>              | <code>str</code>      | 技能的唯一名稱。                                    |
| <code>func</code>              | <code>Callable</code> | 技能實際執行的程式碼函數。                          |
| <code>requires_approval</code> | <code>bool</code>     | (可選) 指示該技能是否需要人工審批，預設為 <code>False</code>。 |</p>
<h3>5.2 <code>AIAgent</code> 類別方法</h3>
<p>| 方法名稱        | 參數                        | 描述                                                               |
| :-------------- | :-------------------------- | :----------------------------------------------------------------- |
| <code>add_skill</code>     | <code>skill: AISkill</code>            | 向 Agent 添加一個技能。                                            |
| <code>execute_skill</code> | <code>skill_name: str, **kwargs</code> | 執行指定名稱的技能，並傳遞參數。如果需要審批，則會觸發 HITL 流程。 |</p>
<h3>5.3 審批請求數據結構 (儲存在 <code>pending_approvals</code> 中)</h3>
<p>| 欄位名稱 | 類型 | 描述 |
| :-------------- | :-------- | :------------------------------------------------------------------- |\n| <code>approval_id</code> | <code>str</code> | 唯一的審批請求 ID。 |
| <code>skill_name</code> | <code>str</code> | 請求執行的技能名稱。 |
| <code>params</code> | <code>Dict</code> | 技能執行所需的參數。 |
| <code>agent_name</code> | <code>str</code> | 發出請求的 AI Agent 名稱。 |
| <code>status</code> | <code>str</code> | 審批狀態 (<code>PENDING</code>, <code>APPROVED</code>, <code>REJECTED</code>, <code>EXPIRED</code>)。 |
| <code>timestamp</code> | <code>float</code> | 請求發出的時間戳。 |</p>
<h3>5.4 外部通知服務介面 (概念性)</h3>
<p>| 方法名稱                     | 參數                                              | 描述                                           |
| :--------------------------- | :------------------------------------------------ | :--------------------------------------------- |
| <code>send_approval_notification</code> | <code>approval_id: str, action_details: Dict</code>          | 向管理者發送審批通知，包含操作詳情和審批連結。 |
| <code>(Webhook Endpoint)</code>         | <code>approval_id: str, status: str, approver_id: str</code> | 接收來自通知服務的回調，更新審批狀態。         |</p>
<h2>6. Notes &amp; Best Practices</h2>
<ol>
<li><strong>明確定義風險等級</strong>：在設計 AI Skill 時，應明確標記其潛在的風險等級和是否需要人工審批。這可以透過 Metadata 標籤（如 <code>[RiskLevel(&quot;High&quot;)]</code>）或獨立的配置檔來實現 [7]。</li>
<li><strong>異步與持久化</strong>：HITL 流程本質上是異步的，AI Agent 的執行必須能夠掛起並在稍後恢復。因此，將 Agent 的狀態和待審批請求持久化到可靠的儲存（如 Redis、資料庫）至關重要，以防止系統重啟或故障導致狀態丟失 [5]。</li>
<li><strong>安全性考量</strong>：<!-- -->
<ul>
<li><strong>審批連結的安全性</strong>：審批連結應具有時效性、唯一性，並可能需要額外的身份驗證，以防止未經授權的批准。避免在 URL 中暴露敏感資訊。</li>
<li><strong>回調驗證</strong>：接收審批結果的回調端點必須驗證請求的來源和簽名，確保其來自合法的通知服務，防止偽造的審批請求 [8]。</li>
<li><strong>最小權限原則</strong>：通知服務和審批服務應僅擁有執行其職責所需的最小權限。</li>
</ul>
</li>
<li><strong>使用者體驗</strong>：<!-- -->
<ul>
<li><strong>清晰的通知內容</strong>：通知訊息應包含足夠的上下文資訊，讓審批人快速理解 AI 意圖和潛在影響，以便做出明智的決策。</li>
<li><strong>多管道通知</strong>：提供多種通知管道（LINE, Discord, Email, Slack），確保管理者能及時收到審批請求。</li>
<li><strong>審批介面簡潔</strong>：審批介面應簡潔明瞭，提供明確的「批准」和「拒絕」選項，並可選填理由。</li>
</ul>
</li>
<li><strong>錯誤處理與超時</strong>：<!-- -->
<ul>
<li><strong>超時機制</strong>：為審批請求設定超時時間。如果超過一定時間未收到批准，請求應自動被拒絕或標記為過期，並通知 AI Agent。</li>
<li><strong>重試機制</strong>：考慮在通知發送失敗時實作重試機制。</li>
</ul>
</li>
<li><strong>可觀測性</strong>：記錄所有審批請求、狀態變更和最終結果，以便進行審計、追蹤和問題排查 [9]。</li>
</ol>
<h2>7. 為什麼選擇這種方式？</h2>
<p>在企業級 AI 應用中引入 Human-in-the-loop (HITL) 與權限控制機制，不僅是技術上的最佳實踐，更是業務與法律合規性的必然要求。這種方式的核心價值體現在以下幾個方面：</p>
<ol>
<li><strong>確保關鍵操作的安全性與責任歸屬</strong>：AI Agent 雖然強大，但仍可能產生錯誤或被惡意利用。透過 HITL，所有可能導致資料損失、財務損失或違反政策的敏感操作，都必須經過人類的明確授權。這將責任歸屬從 AI 轉移到人類決策者，極大地降低了企業風險 [1]。</li>
<li><strong>防範 AI 幻覺與提示詞注入攻擊</strong>：即使是最先進的 LLM 也可能產生不準確或不恰當的內容（幻覺），或者被惡意使用者透過提示詞注入來繞過安全限制。HITL 作為最後一道防線，能夠在這些情況下阻止 AI 執行有害指令，保護系統免受潛在威脅 [10]。</li>
<li><strong>滿足合規性與審計要求</strong>：在金融、醫療、製造等高度監管的行業中，許多操作都必須有明確的審批記錄和人類決策的痕跡。HITL 機制提供了完整的審批日誌，確保了操作的可追溯性和合規性，這對於企業通過審計至關重要 [9]。</li>
<li><strong>提升 AI 系統的信任度與使用者接受度</strong>：當使用者知道 AI Agent 的關鍵決策會有人類監督時，他們對 AI 系統的信任度會顯著提高。這種透明度和控制感有助於推動 AI 技術在企業中的廣泛採用 [2]。</li>
<li><strong>實現 AI 與人類的協同優化</strong>：HITL 不僅僅是安全機制，它也是一個持續改進的循環。人類的審批行為可以作為反饋數據，用於訓練和優化 AI Agent 的決策模型，使其在未來能夠更準確地判斷哪些操作需要人工介入，哪些可以自動執行，從而實現 AI 與人類的協同進化 [11]。</li>
</ol>
<hr/>
<p><strong>參考資料</strong></p>
<ul>
<li>[1] Orkes. (2025, August 18). <em>Human-in-the-Loop in Agentic Workflows: From Definition to Implementation</em>. Retrieved from https://orkes.io/blog/human-in-the-loop/</li>
<li>[2] Zapier. (2025, November 12). <em>Human-in-the-loop in AI workflows: Meaning and patterns</em>. Retrieved from https://zapier.com/blog/human-in-the-loop/</li>
<li>[3] Medium. (2025, September 11). <em>Human-in-the-Loop Middleware: Bringing Oversight into AI Agents</em>. Retrieved from https://medium.com/ai-artistry/human-in-the-loop-middleware-bringing-oversight-into-ai-agents-64eb16dd999d</li>
<li>[4] Microsoft Learn. (2025, November 11). <em>Human-in-the-Loop with AG-UI</em>. Retrieved from https://learn.microsoft.com/en-us/agent-framework/integrations/ag-ui/human-in-the-loop</li>
<li>[5] Docs by LangChain. (n.d.). <em>Interrupts</em>. Retrieved from https://docs.langchain.com/oss/python/langgraph/interrupts</li>
<li>[6] Flowhunt.io. (2025, November 11). <em>Human in the Loop Middleware in Python: Building Safe AI Agents</em>. Retrieved from https://www.flowhunt.io/blog/human-in-the-loop-middleware-python-safe-ai-agents/</li>
<li>[7] Microsoft Learn. (2025, February 19). <em>Semantic Kernel Filters</em>. Retrieved from https://learn.microsoft.com/en-us/semantic-kernel/concepts/enterprise-readiness/filters</li>
<li>[8] GitHub. (n.d.). <em>Human Oversight for Autonomous AI Agents using Azure Logic Apps</em>. Retrieved from https://github.com/microsoft/agents-humanoversight</li>
<li>[9] Medium. (2025, May 7). <em>Human-in-the-Loop with LangGraph: A Beginner&#x27;s Guide</em>. Retrieved from https://sangeethasaravanan.medium.com/human-in-the-loop-with-langgraph-a-beginners-guide-8a32b7f45d6e</li>
<li>[10] Reddit. (2024, August 28). <em>Why does langchain use breakpoints for Human-in-the-loop actions?</em>. Retrieved from https://www.reddit.com/r/LangChain/comments/1f33w2y/why_does_langchain_use_breakpoints_for/</li>
<li>[11] LangChain. (n.d.). <em>Human-in-the-loop using server API</em>. Retrieved from https://docs.langchain.com/langsmith/add-human-in-the-loop</li>
</ul></div></div></div></div></div></article><!--$--><!--/$--><!--$--><!--/$--></main><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><noscript>You need to enable JavaScript to run this app.</noscript><div class="position-fixed" style="z-index:1050;bottom:20px;right:20px;transform:translate(0px, 0px);touch-action:none;cursor:default;display:flex;flex-direction:column;align-items:flex-end;transition:transform 0.3s ease"><div class="position-relative"><button class="btn btn-primary rounded-circle d-flex align-items-center justify-content-center shadow" style="width:56px;height:56px;cursor:grab" aria-label="切換聊天視窗"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width:24px;height:24px;pointer-events:none"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"></path></svg></button><span class="position-absolute bg-danger rounded-circle" style="width:12px;height:12px;top:0;right:0;border:2px solid white"></span></div></div><script src="https://qwer820921.github.io/_next/static/chunks/webpack-6eefbc0fef8fd205.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[69243,[\"8482\",\"static/chunks/8482-5637f60b9e0ae224.js\",\"7177\",\"static/chunks/app/layout-898a3761c5f29253.js\"],\"\"]\n3:I[6476,[\"8482\",\"static/chunks/8482-5637f60b9e0ae224.js\",\"7177\",\"static/chunks/app/layout-898a3761c5f29253.js\"],\"default\"]\n4:I[87555,[],\"\"]\n5:I[31295,[],\"\"]\n6:I[39543,[\"8482\",\"static/chunks/8482-5637f60b9e0ae224.js\",\"7177\",\"static/chunks/app/layout-898a3761c5f29253.js\"],\"default\"]\n8:I[59665,[],\"MetadataBoundary\"]\na:I[59665,[],\"OutletBoundary\"]\nd:I[74911,[],\"AsyncMetadataOutlet\"]\nf:I[59665,[],\"ViewportBoundary\"]\n11:I[26614,[],\"\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/be607b33620c6e00.css\",\"style\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/739e5c607d9731d5.css\",\"style\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/4bb1c53d4d41ca49.css\",\"style\"]\n:HL[\"https://qwer820921.github.io/_next/static/css/0105f7c97f16220d.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"3GxYzBRvbE-S--LqSNUlR\",\"p\":\"https://qwer820921.github.io\",\"c\":[\"\",\"blog\",\"implement-human-in-the-loop-for-ai-skills\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"implement-human-in-the-loop-for-ai-skills\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/be607b33620c6e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/739e5c607d9731d5.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/4bb1c53d4d41ca49.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-Hant\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/favicon.ico\"}],[\"$\",\"link\",null,{\"rel\":\"apple-touch-icon\",\"href\":\"/logo192.png\"}],[\"$\",\"link\",null,{\"rel\":\"manifest\",\"href\":\"/manifest.json\"}],[\"$\",\"link\",null,{\"rel\":\"preload\",\"href\":\"/logo192.png\",\"as\":\"image\"}],[\"$\",\"$L2\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-CCKVESHCQ1\"}],[\"$\",\"$L2\",null,{\"id\":\"google-analytics\",\"children\":\"\\n            window.dataLayer = window.dataLayer || [];\\n            function gtag(){dataLayer.push(arguments);}\\n            gtag('js', new Date());\\n            gtag('config', 'G-CCKVESHCQ1');\\n          \"}],[\"$\",\"$L2\",null,{\"async\":true,\"src\":\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2709303513603814\",\"crossOrigin\":\"anonymous\"}]]}],[\"$\",\"body\",null,{\"children\":[[\"$\",\"$L3\",null,{\"children\":[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"$L6\",null,{}]]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"implement-human-in-the-loop-for-ai-skills\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"https://qwer820921.github.io/_next/static/css/0105f7c97f16220d.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"7mQYOPvvgb83DWBS8si1E\",{\"children\":[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],null]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"12:\"$Sreact.suspense\"\n13:I[74911,[],\"AsyncMetadata\"]\n9:[\"$\",\"$12\",null,{\"fallback\":null,\"children\":[\"$\",\"$L13\",null,{\"promise\":\"$@14\"}]}]\n"])</script><script>self.__next_f.push([1,"15:I[57113,[\"6874\",\"static/chunks/6874-cfa829be98f8140c.js\",\"5953\",\"static/chunks/app/blog/%5Bslug%5D/page-c93c0e23c9658930.js\"],\"default\"]\nc:null\n7:[\"$\",\"article\",null,{\"className\":\"container py-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"row justify-content-center\",\"children\":[\"$\",\"div\",null,{\"className\":\"col-12 col-lg-8\",\"children\":[[\"$\",\"$L15\",null,{}],[\"$\",\"div\",null,{\"className\":\"card shadow-sm border-0\",\"children\":[\"$\",\"div\",null,{\"className\":\"card-body p-4 p-md-5\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-5 pb-4 border-bottom\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"fw-bold mb-3 display-5\",\"children\":\"【安全機制】為 AI Skill 添加「人類授權層 (Human-in-the-loop)」與權限控制\"}],[\"$\",\"div\",null,{\"className\":\"text-muted d-flex align-items-center gap-2\",\"children\":[[\"$\",\"i\",null,{\"className\":\"bi bi-calendar3\"}],\"2026-02-11\"]}]]}],[\"$\",\"div\",null,{\"className\":\"blogContent_blogContent__VY_R4\",\"children\":\"$L16\"}]]}]}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"17:T172b,"])</script><script>self.__next_f.push([1,"import uuid\nimport time\nimport json\nfrom enum import Enum\nfrom typing import Dict, Any, Callable, Optional\n\n# 模擬外部通知服務 (例如 LINE Notify 或 Discord Webhook)\n# 在實際應用中，這裡會發送 HTTP 請求到 LINE/Discord API\ndef send_approval_notification(approval_id: str, action_details: Dict[str, Any]):\n    print(f\"\\n--- 發送審批通知 ---\")\n    print(f\"審批 ID: {approval_id}\")\n    print(f\"請求操作: {action_details['skill_name']}\")\n    print(f\"參數: {json.dumps(action_details['params'], indent=2)}\")\n    print(f\"請訪問此連結批准或拒絕: http://your-approval-service.com/approve/{approval_id}\")\n    print(f\"---------------------\")\n\n# 模擬一個持久化層來儲存掛起的請求\n# 在實際應用中，這會是 Redis 或資料庫\npending_approvals: Dict[str, Dict[str, Any]] = {}\n\nclass ApprovalStatus(Enum):\n    PENDING = \"PENDING\"\n    APPROVED = \"APPROVED\"\n    REJECTED = \"REJECTED\"\n    EXPIRED = \"EXPIRED\"\n\nclass AISkill:\n    def __init__(self, name: str, func: Callable, requires_approval: bool = False):\n        self.name = name\n        self.func = func\n        self.requires_approval = requires_approval\n\n    def execute(self, **kwargs):\n        print(f\"執行 Skill: {self.name} with params: {kwargs}\")\n        return self.func(**kwargs)\n\nclass AIAgent:\n    def __init__(self, name: str):\n        self.name = name\n        self.skills: Dict[str, AISkill] = {}\n\n    def add_skill(self, skill: AISkill):\n        self.skills[skill.name] = skill\n\n    async def execute_skill(self, skill_name: str, **kwargs) -\u003e Any:\n        skill = self.skills.get(skill_name)\n        if not skill:\n            raise ValueError(f\"Skill '{skill_name}' not found.\")\n\n        if skill.requires_approval:\n            print(f\"\\n[Agent] Skill '{skill_name}' 需要人工審批。\")\n            approval_id = str(uuid.uuid4())\n            action_details = {\n                \"skill_name\": skill_name,\n                \"params\": kwargs,\n                \"agent_name\": self.name,\n                \"status\": ApprovalStatus.PENDING.value,\n                \"timestamp\": time.time()\n            }\n            pending_approvals[approval_id] = action_details\n            send_approval_notification(approval_id, action_details)\n\n            # 模擬等待人類審批\n            print(f\"[Agent] 等待人類審批 (ID: {approval_id})...\")\n            while pending_approvals[approval_id][\"status\"] == ApprovalStatus.PENDING.value:\n                await asyncio.sleep(2) # 每 2 秒檢查一次\n\n            if pending_approvals[approval_id][\"status\"] == ApprovalStatus.APPROVED.value:\n                print(f\"[Agent] Skill '{skill_name}' 已獲批准，正在執行...\")\n                result = skill.execute(**kwargs)\n                del pending_approvals[approval_id] # 清理\n                return result\n            else:\n                print(f\"[Agent] Skill '{skill_name}' 被拒絕或過期，中止執行。\")\n                del pending_approvals[approval_id] # 清理\n                return f\"操作 '{skill_name}' 被拒絕或過期。\"\n        else:\n            print(f\"[Agent] Skill '{skill_name}' 無需審批，直接執行。\")\n            return skill.execute(**kwargs)\n\n# 模擬一個後端服務來處理審批回調\n# 在實際應用中，這會是一個 Flask/FastAPI/ASP.NET Core 的 endpoint\nasync def simulate_approval_service(approval_id: str, status: ApprovalStatus):\n    if approval_id in pending_approvals:\n        pending_approvals[approval_id][\"status\"] = status.value\n        print(f\"\\n[Approval Service] 審批 ID {approval_id} 狀態更新為 {status.value}\")\n    else:\n        print(f\"[Approval Service] 錯誤: 審批 ID {approval_id} 不存在或已處理。\")\n\n# 實際的 Skill 函數\ndef sell_stock_func(symbol: str, amount: int):\n    print(f\"--- 執行 SellStock: 賣出 {amount} 股 {symbol} ---\")\n    # 這裡會是實際的交易邏輯\n    return f\"成功賣出 {amount} 股 {symbol}。\"\n\ndef get_stock_price_func(symbol: str):\n    print(f\"--- 執行 GetStockPrice: 獲取 {symbol} 股價 ---\")\n    # 這裡會是實際的股價查詢邏輯\n    return f\"{symbol} 當前股價為 $175.50。\"\n\n# 主程式邏輯\nimport asyncio\n\nasync def main():\n    my_agent = AIAgent(\"FinancialAgent\")\n\n    # 添加需要審批的 Skill\n    my_agent.add_skill(AISkill(\"SellStock\", sell_stock_func, requires_approval=True))\n    # 添加無需審批的 Skill\n    my_agent.add_skill(AISkill(\"GetStockPrice\", get_stock_price_func, requires_approval=False))\n\n    print(\"\\n--- 測試無需審批的 Skill ---\")\n    price_result = await my_agent.execute_skill(\"GetStockPrice\", symbol=\"MSFT\")\n    print(f\"結果: {price_result}\")\n\n    print(\"\\n--- 測試需要審批的 Skill ---\")\n    # 模擬 AI 嘗試賣出股票\n    sell_task = asyncio.create_task(my_agent.execute_skill(\"SellStock\", symbol=\"GOOG\", amount=50))\n\n    # 模擬人類在收到通知後進行批准\n    await asyncio.sleep(5) # 等待通知發送\n    # 假設我們知道審批 ID (從 pending_approvals 中獲取第一個)\n    if pending_approvals:\n        first_approval_id = list(pending_approvals.keys())[0]\n        print(f\"\\n[Main] 模擬人類批准操作 (ID: {first_approval_id})...\")\n        await simulate_approval_service(first_approval_id, ApprovalStatus.APPROVED)\n\n    sell_result = await sell_task\n    print(f\"結果: {sell_result}\")\n\n    print(\"\\n--- 測試需要審批但被拒絕的 Skill ---\")\n    reject_task = asyncio.create_task(my_agent.execute_skill(\"SellStock\", symbol=\"AMZN\", amount=10))\n    await asyncio.sleep(5)\n    if pending_approvals:\n        second_approval_id = list(pending_approvals.keys())[0]\n        print(f\"\\n[Main] 模擬人類拒絕操作 (ID: {second_approval_id})...\")\n        await simulate_approval_service(second_approval_id, ApprovalStatus.REJECTED)\n    reject_result = await reject_task\n    print(f\"結果: {reject_result}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n"])</script><script>self.__next_f.push([1,"16:[[\"$\",\"h1\",null,{\"children\":\"【安全機制】為 AI Skill 添加「人類授權層 (Human-in-the-loop)」與權限控制\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"作者：\"}],\" Yee\\n\",[\"$\",\"strong\",null,{\"children\":\"日期：\"}],\" 2026年2月11日\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"1. Overview\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"隨著 AI Agent 的能力日益增強，它們被賦予了執行複雜任務和存取敏感系統的權限。然而，這也帶來了新的安全挑戰：如何確保 AI Agent 不會執行危險、不當或未經授權的操作？例如，一個 AI Agent 可能會錯誤地刪除資料庫、進行未經批准的金融交易，或者在遊戲中執行破壞性行為。傳統的程式安全機制不足以完全應對 LLM 可能產生的「幻覺（Hallucination）」或「提示詞注入（Prompt Injection）」攻擊 [1]。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"為了解決這些問題，**「人類授權層（Human-in-the-loop, HITL）」**成為 Agentic AI 系統中不可或缺的安全機制。HITL 旨在將人類的判斷和監督整合到自動化流程的關鍵決策點，特別是在 AI Agent 嘗試執行高風險或敏感操作之前 [2]。它透過引入一個「確認機制」，確保所有可能產生重大影響的 AI Skill 執行都必須經過人類的明確批准。\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"本文件將深入探討如何在 AI Skill 的執行流程中實作一個強健的 HITL 機制。我們將介紹如何利用 \",[\"$\",\"strong\",null,{\"children\":[\"Middleware（中介層）\",[\"$\",\"strong\",null,{\"children\":\"模式攔截 AI 的工具呼叫（Tool Call），建立一個\"}],\"異步審批工作流（Asynchronous Approval Workflow）\"]}],\"，並整合外部通知系統（如 LINE Notify 或 Discord Webhook）來實現遠端批准。這不僅能大幅提升 AI 應用的安全性與責任歸屬，也能滿足企業在金融、醫療等受監管行業的合規性要求。\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"2. Architecture / Design\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"實作 Human-in-the-loop (HITL) 機制的核心在於在 AI Agent 決定執行一個 Skill 與該 Skill 實際執行之間，插入一個可控的「審批閘門」。這個閘門需要能夠攔截請求、通知人類、等待批准，並在收到批准後才放行執行。以下是其架構設計的核心模式 [3]。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"2.1 攔截器模式 (The Interceptor Pattern)\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"核心思想\"}],\"：在 AI Agent 框架（如 LangChain、Semantic Kernel）中，當 AI 決定呼叫一個外部工具或執行一個 Native Function 時，不應立即執行。而是在這個「呼叫」與「執行」之間，插入一個自定義的攔截器（Interceptor）或過濾器（Filter） [4]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Middleware/Filters\"}],\"：這個攔截器作為一個中介層，負責檢查即將執行的 Skill 是否被標記為「敏感」或「需要人工審批」。如果符合條件，它將阻止 Skill 的直接執行。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"掛起狀態 (State Suspension)\"}],\"：當攔截器阻止執行時，AI Agent 的當前執行狀態（包括其思考過程、上下文、即將執行的 Skill 及其參數）需要被\",[\"$\",\"strong\",null,{\"children\":\"持久化（Check-pointing）\"}],\"。Agent 的執行將被暫停，進入等待（Pending）模式，直到收到人類的審批結果 [5]。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"2.2 異步審批工作流 (Asynchronous Approval Workflow)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"這是 HITL 機制的關鍵部分，它定義了人類介入的流程：\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"AI 觸發敏感操作 (Trigger)\"}],\"：AI Agent 根據其推理結果，產生一個需要執行敏感操作的意圖，例如 \",[\"$\",\"code\",null,{\"children\":\"SellStock(symbol=\\\"AAPL\\\", amount=100)\"}],\" 或 \",[\"$\",\"code\",null,{\"children\":\"DeleteDatabase(dbName=\\\"Production\\\")\"}],\"。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"攔截與識別 (Intercept \u0026 Identify)\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"攔截器捕獲到這個 Skill 呼叫。它會檢查該 Skill 的元數據（Metadata），例如 \",[\"$\",\"code\",null,{\"children\":\"[RiskLevel(\\\"High\\\")]\"}],\" 或 \",[\"$\",\"code\",null,{\"children\":\"[RequiresApproval(true)]\"}],\"，判斷其是否需要人工審批。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"如果需要審批，攔截器會提取 Skill 的詳細資訊（名稱、參數、AI 的推理過程等），並將其與當前 Agent 的會話 ID 一起儲存到一個**持久化層（Persistence Layer）**中。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"發送通知 (Notify)\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"系統會透過一個通知服務，向預定義的管理者或審批人發送審批請求。通知可以透過多種管道發送，例如：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"LINE Notify\"}],\"：發送包含操作詳情和「批准/拒絕」按鈕的訊息。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Discord Webhook\"}],\"：發送嵌入式訊息（Embed Message），提供互動式按鈕。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Email/Slack\"}],\"：發送包含審批連結的通知。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"通知中應包含一個唯一的\",[\"$\",\"strong\",null,{\"children\":\"審批 ID (Approval ID)\"}],\"，用於後續的回調。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"人類審批 (Human Approval)\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"管理者收到通知後，審閱 AI 提出的操作請求。基於對業務影響、風險和 AI 推理的理解，管理者決定「批准」或「拒絕」該操作。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"管理者透過點擊通知中的按鈕或訪問特定的審批介面，提交審批結果。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"接收回調與恢復 (Receive Callback \u0026 Resume)\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"系統接收到來自通知服務的回調（Callback），其中包含審批 ID 和審批結果（批准/拒絕）。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"系統根據審批 ID 從持久化層中檢索出之前掛起的 Agent 狀態。\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"如果審批結果是「批准」，Agent 的執行將從掛起點恢復，並執行原定的 Skill。如果審批結果是「拒絕」，則 Skill 執行被中止，Agent 可能會收到一個錯誤訊息，並根據其邏輯重新規劃或通知使用者 [6]。\"}],\"\\n\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"2.3 權限控制與角色管理\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"除了 HITL，細粒度的權限控制也是確保 AI Agent 安全的關鍵：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"基於角色的存取控制 (RBAC)\"}],\"：定義不同的使用者角色（例如：開發者、業務經理、安全審計員），並為每個角色分配不同的審批權限。例如，只有特定的安全團隊成員才能批准資料庫刪除操作。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"操作敏感度分級\"}],\"：為每個 Skill 定義一個敏感度級別（例如：低、中、高）。只有達到特定敏感度級別的 Skill 才需要觸發 HITL 流程。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"審批策略\"}],\"：可以設定多級審批（例如：需要兩人同時批准）或基於金額的審批（例如：交易金額超過 $10000 需要批准）。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"3. Prerequisites\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"要實作一個帶有 HITL 的 AI Skill 安全機制，您需要具備以下環境和知識：\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"AI Agent 框架\"}],\"：熟悉您選擇的 AI Agent 框架，例如 LangChain、LangGraph、Semantic Kernel 或自定義 Agent 框架。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"程式語言\"}],\"：熟悉 Python (LangChain/LangGraph) 或 C# (Semantic Kernel) 等程式語言。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"Web 服務開發\"}],\"：需要具備開發 Web API 的能力，用於接收通知服務的回調。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"持久化層\"}],\"：熟悉資料庫（如 PostgreSQL, MongoDB）或鍵值儲存（如 Redis）的使用，用於儲存 Agent 狀態和審批請求。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"通知服務 API\"}],\"：了解 LINE Notify、Discord Webhook 或其他通知服務的 API 整合。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"非同步程式設計\"}],\"：理解 \",[\"$\",\"code\",null,{\"children\":\"async/await\"}],\" 等非同步程式設計模式，以處理異步審批工作流。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"4. Implementation / Code Example\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"本節將提供一個概念性的 Python 程式碼範例，展示如何在一個簡化的 AI Agent 框架中實作 HITL。我們將模擬一個 \",[\"$\",\"code\",null,{\"children\":\"SellStock\"}],\" Skill，並在執行前觸發人工審批。\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.1 模擬 AI Agent 框架與 Skill 定義\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-python\",\"children\":\"$17\"}]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"4.2 程式碼說明\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"send_approval_notification\"}]}],\"：模擬向外部通知服務發送請求，其中包含審批 ID 和操作詳情。在實際應用中，這會是一個 HTTP POST 請求到 LINE Notify 或 Discord Webhook API。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"pending_approvals\"}]}],\"：一個字典，模擬持久化層，用於儲存所有待審批的請求。鍵是唯一的 \",[\"$\",\"code\",null,{\"children\":\"approval_id\"}],\"，值是包含 Skill 名稱、參數、狀態等資訊的字典。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"AISkill\"}],\" 類別\"]}],\"：代表一個 AI Agent 可以執行的技能。新增了 \",[\"$\",\"code\",null,{\"children\":\"requires_approval\"}],\" 屬性來標記該 Skill 是否需要人工審批。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"AIAgent\"}],\" 類別\"]}],\"：\",[\"$\",\"code\",null,{\"children\":\"execute_skill\"}],\" 方法是核心。當 \",[\"$\",\"code\",null,{\"children\":\"skill.requires_approval\"}],\" 為 \",[\"$\",\"code\",null,{\"children\":\"True\"}],\" 時，它會生成一個 \",[\"$\",\"code\",null,{\"children\":\"approval_id\"}],\"，將請求資訊儲存到 \",[\"$\",\"code\",null,{\"children\":\"pending_approvals\"}],\"，並呼叫 \",[\"$\",\"code\",null,{\"children\":\"send_approval_notification\"}],\"。然後進入一個循環，等待 \",[\"$\",\"code\",null,{\"children\":\"pending_approvals\"}],\" 中對應請求的狀態更新。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"simulate_approval_service\"}]}],\"：模擬一個後端 API 端點，接收來自通知服務的回調，並更新 \",[\"$\",\"code\",null,{\"children\":\"pending_approvals\"}],\" 中請求的狀態。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"main\"}],\" 函數\"]}],\"：展示了如何創建 Agent、添加 Skill，並測試需要審批和無需審批的 Skill。它還模擬了人類批准和拒絕的過程。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"5. Parameters / API Reference\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"本節將基於上述範例，抽象出實作 HITL 機制時可能涉及的關鍵參數和介面。\"}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"5.1 \",[\"$\",\"code\",null,{\"children\":\"AISkill\"}],\" 類別參數\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"| 參數名稱            | 類型       | 描述                                                |\\n| :------------------ | :--------- | :-------------------------------------------------- |\\n| \",[\"$\",\"code\",null,{\"children\":\"name\"}],\"              | \",[\"$\",\"code\",null,{\"children\":\"str\"}],\"      | 技能的唯一名稱。                                    |\\n| \",[\"$\",\"code\",null,{\"children\":\"func\"}],\"              | \",[\"$\",\"code\",null,{\"children\":\"Callable\"}],\" | 技能實際執行的程式碼函數。                          |\\n| \",[\"$\",\"code\",null,{\"children\":\"requires_approval\"}],\" | \",[\"$\",\"code\",null,{\"children\":\"bool\"}],\"     | (可選) 指示該技能是否需要人工審批，預設為 \",[\"$\",\"code\",null,{\"children\":\"False\"}],\"。 |\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"5.2 \",[\"$\",\"code\",null,{\"children\":\"AIAgent\"}],\" 類別方法\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"| 方法名稱        | 參數                        | 描述                                                               |\\n| :-------------- | :-------------------------- | :----------------------------------------------------------------- |\\n| \",[\"$\",\"code\",null,{\"children\":\"add_skill\"}],\"     | \",[\"$\",\"code\",null,{\"children\":\"skill: AISkill\"}],\"            | 向 Agent 添加一個技能。                                            |\\n| \",[\"$\",\"code\",null,{\"children\":\"execute_skill\"}],\" | \",[\"$\",\"code\",null,{\"children\":\"skill_name: str, **kwargs\"}],\" | 執行指定名稱的技能，並傳遞參數。如果需要審批，則會觸發 HITL 流程。 |\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":[\"5.3 審批請求數據結構 (儲存在 \",[\"$\",\"code\",null,{\"children\":\"pending_approvals\"}],\" 中)\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"| 欄位名稱 | 類型 | 描述 |\\n| :-------------- | :-------- | :------------------------------------------------------------------- |\\\\n| \",[\"$\",\"code\",null,{\"children\":\"approval_id\"}],\" | \",[\"$\",\"code\",null,{\"children\":\"str\"}],\" | 唯一的審批請求 ID。 |\\n| \",[\"$\",\"code\",null,{\"children\":\"skill_name\"}],\" | \",[\"$\",\"code\",null,{\"children\":\"str\"}],\" | 請求執行的技能名稱。 |\\n| \",[\"$\",\"code\",null,{\"children\":\"params\"}],\" | \",[\"$\",\"code\",null,{\"children\":\"Dict\"}],\" | 技能執行所需的參數。 |\\n| \",[\"$\",\"code\",null,{\"children\":\"agent_name\"}],\" | \",[\"$\",\"code\",null,{\"children\":\"str\"}],\" | 發出請求的 AI Agent 名稱。 |\\n| \",[\"$\",\"code\",null,{\"children\":\"status\"}],\" | \",[\"$\",\"code\",null,{\"children\":\"str\"}],\" | 審批狀態 (\",[\"$\",\"code\",null,{\"children\":\"PENDING\"}],\", \",[\"$\",\"code\",null,{\"children\":\"APPROVED\"}],\", \",[\"$\",\"code\",null,{\"children\":\"REJECTED\"}],\", \",[\"$\",\"code\",null,{\"children\":\"EXPIRED\"}],\")。 |\\n| \",[\"$\",\"code\",null,{\"children\":\"timestamp\"}],\" | \",[\"$\",\"code\",null,{\"children\":\"float\"}],\" | 請求發出的時間戳。 |\"]}],\"\\n\",[\"$\",\"h3\",null,{\"children\":\"5.4 外部通知服務介面 (概念性)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"| 方法名稱                     | 參數                                              | 描述                                           |\\n| :--------------------------- | :------------------------------------------------ | :--------------------------------------------- |\\n| \",[\"$\",\"code\",null,{\"children\":\"send_approval_notification\"}],\" | \",[\"$\",\"code\",null,{\"children\":\"approval_id: str, action_details: Dict\"}],\"          | 向管理者發送審批通知，包含操作詳情和審批連結。 |\\n| \",[\"$\",\"code\",null,{\"children\":\"(Webhook Endpoint)\"}],\"         | \",[\"$\",\"code\",null,{\"children\":\"approval_id: str, status: str, approver_id: str\"}],\" | 接收來自通知服務的回調，更新審批狀態。         |\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"6. Notes \u0026 Best Practices\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"明確定義風險等級\"}],\"：在設計 AI Skill 時，應明確標記其潛在的風險等級和是否需要人工審批。這可以透過 Metadata 標籤（如 \",[\"$\",\"code\",null,{\"children\":\"[RiskLevel(\\\"High\\\")]\"}],\"）或獨立的配置檔來實現 [7]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"異步與持久化\"}],\"：HITL 流程本質上是異步的，AI Agent 的執行必須能夠掛起並在稍後恢復。因此，將 Agent 的狀態和待審批請求持久化到可靠的儲存（如 Redis、資料庫）至關重要，以防止系統重啟或故障導致狀態丟失 [5]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"安全性考量\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"審批連結的安全性\"}],\"：審批連結應具有時效性、唯一性，並可能需要額外的身份驗證，以防止未經授權的批准。避免在 URL 中暴露敏感資訊。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"回調驗證\"}],\"：接收審批結果的回調端點必須驗證請求的來源和簽名，確保其來自合法的通知服務，防止偽造的審批請求 [8]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"最小權限原則\"}],\"：通知服務和審批服務應僅擁有執行其職責所需的最小權限。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"使用者體驗\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"清晰的通知內容\"}],\"：通知訊息應包含足夠的上下文資訊，讓審批人快速理解 AI 意圖和潛在影響，以便做出明智的決策。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"多管道通知\"}],\"：提供多種通知管道（LINE, Discord, Email, Slack），確保管理者能及時收到審批請求。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"審批介面簡潔\"}],\"：審批介面應簡潔明瞭，提供明確的「批准」和「拒絕」選項，並可選填理由。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"錯誤處理與超時\"}],\"：\",\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"超時機制\"}],\"：為審批請求設定超時時間。如果超過一定時間未收到批准，請求應自動被拒絕或標記為過期，並通知 AI Agent。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"重試機制\"}],\"：考慮在通知發送失敗時實作重試機制。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"可觀測性\"}],\"：記錄所有審批請求、狀態變更和最終結果，以便進行審計、追蹤和問題排查 [9]。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"7. 為什麼選擇這種方式？\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"在企業級 AI 應用中引入 Human-in-the-loop (HITL) 與權限控制機制，不僅是技術上的最佳實踐，更是業務與法律合規性的必然要求。這種方式的核心價值體現在以下幾個方面：\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"確保關鍵操作的安全性與責任歸屬\"}],\"：AI Agent 雖然強大，但仍可能產生錯誤或被惡意利用。透過 HITL，所有可能導致資料損失、財務損失或違反政策的敏感操作，都必須經過人類的明確授權。這將責任歸屬從 AI 轉移到人類決策者，極大地降低了企業風險 [1]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"防範 AI 幻覺與提示詞注入攻擊\"}],\"：即使是最先進的 LLM 也可能產生不準確或不恰當的內容（幻覺），或者被惡意使用者透過提示詞注入來繞過安全限制。HITL 作為最後一道防線，能夠在這些情況下阻止 AI 執行有害指令，保護系統免受潛在威脅 [10]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"滿足合規性與審計要求\"}],\"：在金融、醫療、製造等高度監管的行業中，許多操作都必須有明確的審批記錄和人類決策的痕跡。HITL 機制提供了完整的審批日誌，確保了操作的可追溯性和合規性，這對於企業通過審計至關重要 [9]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"提升 AI 系統的信任度與使用者接受度\"}],\"：當使用者知道 AI Agent 的關鍵決策會有人類監督時，他們對 AI 系統的信任度會顯著提高。這種透明度和控制感有助於推動 AI 技術在企業中的廣泛採用 [2]。\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"實現 AI 與人類的協同優化\"}],\"：HITL 不僅僅是安全機制，它也是一個持續改進的循環。人類的審批行為可以作為反饋數據，用於訓練和優化 AI Agent 的決策模型，使其在未來能夠更準確地判斷哪些操作需要人工介入，哪些可以自動執行，從而實現 AI 與人類的協同進化 [11]。\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"strong\",null,{\"children\":\"參考資料\"}]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[1] Orkes. (2025, August 18). \",[\"$\",\"em\",null,{\"children\":\"Human-in-the-Loop in Agentic Workflows: From Definition to Implementation\"}],\". Retrieved from https://orkes.io/blog/human-in-the-loop/\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[2] Zapier. (2025, November 12). \",[\"$\",\"em\",null,{\"children\":\"Human-in-the-loop in AI workflows: Meaning and patterns\"}],\". Retrieved from https://zapier.com/blog/human-in-the-loop/\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[3] Medium. (2025, September 11). \",[\"$\",\"em\",null,{\"children\":\"Human-in-the-Loop Middleware: Bringing Oversight into AI Agents\"}],\". Retrieved from https://medium.com/ai-artistry/human-in-the-loop-middleware-bringing-oversight-into-ai-agents-64eb16dd999d\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[4] Microsoft Learn. (2025, November 11). \",[\"$\",\"em\",null,{\"children\":\"Human-in-the-Loop with AG-UI\"}],\". Retrieved from https://learn.microsoft.com/en-us/agent-framework/integrations/ag-ui/human-in-the-loop\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[5] Docs by LangChain. (n.d.). \",[\"$\",\"em\",null,{\"children\":\"Interrupts\"}],\". Retrieved from https://docs.langchain.com/oss/python/langgraph/interrupts\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[6] Flowhunt.io. (2025, November 11). \",[\"$\",\"em\",null,{\"children\":\"Human in the Loop Middleware in Python: Building Safe AI Agents\"}],\". Retrieved from https://www.flowhunt.io/blog/human-in-the-loop-middleware-python-safe-ai-agents/\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[7] Microsoft Learn. (2025, February 19). \",[\"$\",\"em\",null,{\"children\":\"Semantic Kernel Filters\"}],\". Retrieved from https://learn.microsoft.com/en-us/semantic-kernel/concepts/enterprise-readiness/filters\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[8] GitHub. (n.d.). \",[\"$\",\"em\",null,{\"children\":\"Human Oversight for Autonomous AI Agents using Azure Logic Apps\"}],\". Retrieved from https://github.com/microsoft/agents-humanoversight\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[9] Medium. (2025, May 7). \",[\"$\",\"em\",null,{\"children\":\"Human-in-the-Loop with LangGraph: A Beginner's Guide\"}],\". Retrieved from https://sangeethasaravanan.medium.com/human-in-the-loop-with-langgraph-a-beginners-guide-8a32b7f45d6e\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[10] Reddit. (2024, August 28). \",[\"$\",\"em\",null,{\"children\":\"Why does langchain use breakpoints for Human-in-the-loop actions?\"}],\". Retrieved from https://www.reddit.com/r/LangChain/comments/1f33w2y/why_does_langchain_use_breakpoints_for/\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"[11] LangChain. (n.d.). \",[\"$\",\"em\",null,{\"children\":\"Human-in-the-loop using server API\"}],\". Retrieved from https://docs.langchain.com/langsmith/add-human-in-the-loop\"]}],\"\\n\"]}]]\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"14:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"【安全機制】為 AI Skill 添加「人類授權層 (Human-in-the-loop)」與權限控制 | 子yee 萬事屋 | 子yee\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"深入探討如何在 Agentic AI 系統中實作 Human-in-the-loop (HITL) 機制，透過 Middleware 攔截、異步審批工作流與權限控制，確保 AI Skill 執行的安全性與合規性。\"}],[\"$\",\"meta\",\"2\",{\"name\":\"keywords\",\"content\":\"子yee 萬事屋, 台股查詢, 自選股, 技術小工具, 股票資訊平台, 技術顧問, 自動化工具\"}],[\"$\",\"meta\",\"3\",{\"name\":\"google-site-verification\",\"content\":\"adHIcDQiasHY4YzPlrpmSSPKl7Oj1WxrPJ_4GV4PQcM\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"【安全機制】為 AI Skill 添加「人類授權層 (Human-in-the-loop)」與權限控制\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"深入探討如何在 Agentic AI 系統中實作 Human-in-the-loop (HITL) 機制，透過 Middleware 攔截、異步審批工作流與權限控制，確保 AI Skill 執行的安全性與合規性。\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:image\",\"content\":\"https://qwer820921.github.io/images/img15.jpg\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image:height\",\"content\":\"630\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:image:alt\",\"content\":\"【安全機制】為 AI Skill 添加「人類授權層 (Human-in-the-loop)」與權限控制\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"11\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:title\",\"content\":\"【安全機制】為 AI Skill 添加「人類授權層 (Human-in-the-loop)」與權限控制\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:description\",\"content\":\"深入探討如何在 Agentic AI 系統中實作 Human-in-the-loop (HITL) 機制，透過 Middleware 攔截、異步審批工作流與權限控制，確保 AI Skill 執行的安全性與合規性。\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:image\",\"content\":\"https://qwer820921.github.io/images/img15.jpg\"}],[\"$\",\"link\",\"15\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"e:{\"metadata\":\"$14:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>